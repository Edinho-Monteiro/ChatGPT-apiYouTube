	Apostila de NodeJS 100% Gratuita

	January 12, 2020

	Esta apostila √© o resultado de alguns meses de pesquisa, revis√£o e edi√ß√£o, foi baseada na documenta√ß√£o oficial (ent√£o as informa√ß√µes s√£o confi√°veis).

	Este conte√∫do eu iria colocar no como adicional no Guia do Dev Autodidata (que √© o meu guia para iniciantes). Mas resolvi deixar gratuito a toda a comunidade, ent√£o aproveite e bons estudos!

	Se tiver qualquer d√∫vida (ou sugest√µes) me envie no Instagram, fa√ßo mentoria coletiva (gratuita) diariamente para programadores iniciantes que se sentem perdidos, voc√™ ser√° extremamente bem vindo por l√° (√© s√≥ clicar na imagem).

	Um grande abra√ßo, Paulo Luan.

	Introdu√ß√£o ao Node.js

	Node.js √© um ambiente de execu√ß√£o JavaScript open source e multiplataforma. √â uma ferramenta popular para quase todo tipo de projeto!

	Node.js roda na engine (motor) V8, o cora√ß√£o do Google Chrome, fora do navegador. Isso permite que o Node.js seja muito perform√°tico.

	Uma aplica√ß√£o Node.js roda em um √∫nico processo, sem criar uma nova thread para cada requisi√ß√£o. O Node.js prov√™ uma s√©rie de primitivas ass√≠ncronas para I/O (input/output) em sua biblioteca nativa que previnem c√≥digos JavaScript bloqueantes, e geralmente, bibliotecas em Node.js s√£o escritas usando como padr√£o paradigmas n√£o-bloqueantes, fazendo com que o comportamento de bloqueio seja uma exce√ß√£o √† regra.

	Quando o Node.js executa opera√ß√µes de I/O, como ler dados da rede, acessar um banco de dados ou o sistema de arquivos, em vez de bloquear a thread em execu√ß√£o e gastar ciclos de CPU esperando, o Node.js vai continuar com as opera√ß√µes quando a resposta retornar.

	Isso permite com que o Node.js lide com centenas de conex√µes paralelas em um √∫nico servidor, removendo o fardo de gerenciar concorr√™ncias em threads, que podem ser fontes significativas de bugs.

	Node.js tem uma vantagem √∫nica poque milh√µes de desenvolvedores frontend que programam JavaScript para o navegador possam agora desenvolver c√≥digo server-side (backend) al√©m do client-side (frontend), sem a necessidade de aprender uma linguagem completamente diferente.

	No Node.js os novos padr√µes do ECMAScript podem ser utilizados sem problemas, como voc√™ n√£o precisa esperar todos os seus usu√°rios atualizarem seus navegadores, voc√™ tem a liberdade de decidir qual vers√£o do ECMAScript utilizar, bastando trocar a vers√£o do Node.js, al√©m de poder habilitar especificamente features experimentais, bastando executar o Node.Js com as flags apropriadas.

	Um n√∫mero imenso de bibliotecas

	O npm (node package manager) com sua simples estrutura ajudou na plorifera√ß√£o do ecossistema Node.js, hospedando atualmente mais de 1,000,000 de pacotes open source que podem ser utilizados gratuitamente.

	Um exemplo de aplica√ß√£o Node.js

	O exemplo mais comum de Hello World no Node.js √© um servidor web:

	const http = require('http')



	const hostname = '127.0.0.1'

	const port = 3000



	const server = http.createServer((req, res) => {

	 res.statusCode = 200

	 res.setHeader('Content-Type', 'text/plain')

	 res.end('Hello World\n')

	})



	server.listen(port, hostname, () => {

	 console.log(`Server running at http://${hostname}:${port}/`)

	})

	Para executar esse trecho, salve-o como server.js e rode com node server.js no seu terminal.

	Primeiramente esse c√≥digo importa o m√≥dulo http.

	O Node.js tem uma biblioteca padr√£o fant√°stica, incluindo suporte de primeira classe para redes.

	O m√©todo createServer() do http cria um novo servidor HTTP e o retorna.

	√â definido para o servidor escutar em uma porta e host name (nome de anfitri√£o, ao p√© da letra) espec√≠ficos. Quando o servidor est√° pronto, a fun√ß√£o callback √© chamada, nesse caso nos informando que o servidor est√° rodando.

	Sempre que uma nova requisi√ß√£o √© recebida, o evento de request √© chamado, provendo dois objetos: uma requisi√ß√£o (objeto do tipo http.IncomingMessage) e uma resposta (objeto do tipo http.ServerResponse).

	Esses 2 objetos s√£o essenciais para manusear a chamada HTTP.

	O primeiro prov√™ os detalhes da requisi√ß√£o. Nesse simples exemplo, ele n√£o √© utilizado, mas com ele voc√™ pode acessar os dados da request e as headers.

	O segundo √© usado para retornar dados para quem o chamou.

	Nesse caso com:

	res.statusCode = 200

	n√≥s definimos a propriedade statusCode como 200, para indicar uma resposta bem sucedida.

	N√≥s definimos a header de Content-Type (tipo de conte√∫do):

	res.setHeader('Content-Type', 'text/plain')

	e n√≥s fechamos a resposta, adicionando o conte√∫do como um argumento do end():

	res.end('Hello World\n')

	Frameworks e ferramentas para Node.js

	Node.js √© uma plataforma de baixo n√≠vel. Para facilitar e inspirar os desenvolvedores, milhares de bibliotecas s√£o construidas sob o Node.js pela comunidade.

	Muitas delas se estabaleceram como op√ß√µes populares ao decorrer do tempo. Aqui est√° uma pequena lista com algumas que valem a pena aprender:

	 	AdonisJs: Um framework full-stack altamente focado na ergonomia, estabilidade e confian√ßa do desenvolvedor. Adonis √© um dos frameworks web Node.js mais r√°pidos.

	Express: Prov√™ os meios de se criar servidores web de uma forma muito simples por√©m poderosa. T√™m uma pegada minimalista, n√£o opinada, focada nas fun√ß√µes essenciais de um servidor, que s√£o a chave do sucesso.

	Fastify: Um framework altamente focado em prover a melhor experi√™ncia ao desenvolvedor, com o m√≠nimo de gargalos na performance e uma podesora arquitetura de extens√µes (plugins). Fastify √© um dos mais r√°pidos frameworks Node.js.

	Gatsby: Um gerador de sites est√°ticos baseado em React, gerido com GraphQL e com um ecossistema de plugins e templates iniciais requ√≠ssimo.

	hapi: Um rico framework para constru√ß√£o de aplica√ß√µes e servi√ßos que habilitam desenvolvedores a focar na escrita das l√≥gicas de aplica√ß√£o reutiliz√°veis em vez de perder tempo montando a infraestrutura.

	koa: √â mantido pelo time por tr√°s do Express, pretende ser ainda menor e simples, construido sob muitos anos de conhecimento. O novo projeto nasceu da necessidade de criar mudan√ßas incompat√≠veis sem romper com a comunidade existente.

	Loopback.io: Faz com que seja f√°cil construir aplica√ß√µes modernas que requerem integra√ß√µes complexas.

	Meteor: Um framework full-stack incrivelmente poderoso, permite que voc√™ crie apli√ß√µes Javascript com uma abordagem isom√≥rfica, compartilhando c√≥digo entre cliente e servidor. √â uma ferramenta generalista que tenta fornecer tudo, que agora integra com bibliotecas frontend como React, Vue, e Angular. Tamb√©m pode ser utilizado para criar aplicativos mobile.

	Micro: Prov√™ um servidor enxuto para cria√ß√£o de microservi√ßos HTTP ass√≠ncronos.

	NestJS: Um framework Node.js progressivo baseado em Typescript para constru√ß√£o de aplica√ß√£o de n√≠vel empresarial eficientes, confi√°veis e escal√°veis.

	Next.js: Framework React que fornce a melhor experi√™ncia de desenvolvimento, com todos os recursos que voc√™ precisa para produ√ß√£o: renderiza√ß√£o h√≠brida entre servidor (SSR) e est√°ticos, suporte ao TypeScript, bundle otimizado, rotas pre-fetching, e mais.

	Nx: Um conjunto de ferramentas para desenvolvimento full-stack em monorepo, utilizando NestJS, React, Angular, e mais! Nx ajuda a escalar seu desenvolvimento de um time construindo uma aplica√ß√£o para m√∫ltiplos times colaborando em m√∫ltiplas aplica√ß√µes!

	Sapper: Sapper √© um framework para constru√ß√£o de aplica√ß√µes web de todos os tamanhos, com uma bela experi√™ncias de desenvolvimento e roteamento flex√≠vel baseado em filesystems. Oferece SSR e muito mais!

	Socket.io: Um motor de comuni√ß√£o em tempo real para construir aplica√ß√µes em rede.

	Strapi: Strapi √© um CMS flex√≠vel, open-source e independente, que fornece aos desenvolvedores a liberdade de escolher seus frameworks e ferramentas favoritos, enquanto tamb√©m permite que editores administrem e distribuam seus conte√∫dos de maneira f√°cil. Por fazer o painel administrativo uma API extens√≠vel atrav√©s de um sistema de plugins, o Strapi permite que as maiores empresas do mundo acelerem a entrega de conte√∫do enquanto constroem belas experi√™ncias digitais.



	Uma breve hist√≥ria do Node.js

	Acredite ou n√£o, Node.js s√≥ tem 11 anos de idade.

	Em compara√ß√£o, o JavaScript tem 24 anos e a Web tem 31 anos.

	Na tecnologia, 11 anos n√£o √© um tempo muito longo, mas o Node.js parece ter existido sempre.

	Eu tive o prazer de trabalhar com Node.js desde os prim√≥rdios quando ele s√≥ tinha 2 anos, e apesar das informa√ß√µes limitadas pela web, voc√™ j√° podia sentir que o crescimento seria enorme.

	Nesse post, vamos dissecar a hist√≥ria do Node.js, para colocar as coisas em perspectiva.

	Um pouco de hist√≥ria

	JavaScript √© uma linguagem de programa√ß√£o que foi criada no Netscape como uma ferramente de scripts para manipula√ß√£o de p√°ginas web dentro do browser Netscape Navigator.

	Parte do modelo de neg√≥cios da Netscape era vender servidores web, o que incluia um ambiente chamado Netscape LiveWire, que podia criar p√°ginas din√¢micas usando JavaScript no server-side. Infelizmente, o Netscape LiveWire n√£o obteve muito sucesso e JavaScript server-side n√£o era popular at√© recentemente, com a introdu√ß√£o do Node.js

	Um fator chave que levou o Node.js ao topo foi o timing. Apenas alguns poucos anos antes, Javascript come√ßou a ser mais considerado como uma linguagem s√©ria, gra√ßas √†s aplica√ß√µes ‚ÄúWeb 2.0‚Äù (como Flickr, Gmail, etc.) que mostraram ao mundo como poderia ser uma experi√™ncia moderna na web.

	Motores JavaScript (engines) tamb√©m se tornaram consideravelmente melhores com a competi√ß√£o entre v√°rios browsers para fornecer aos usu√°rios a melhor performance. Times de desenvolvimento por tr√°s dos maiores browsers trabalharam duro para oferecer melhor suporte para o JavaScript e encontrar meios que o fizesse rodar mais r√°pido. A engine que roda por baixo dos panos do Node.js, V8 (tamb√©m conhecida como Chrome V8 por ser a engine Javascript open-source do Projeto Chromium), melhorou significamente devido a esta competi√ß√£o.

	Aconteceu de o Node.js ser criado no lugar certo e na hora certa, mas sorte n√£o √© a √∫nica raz√£o do porqu√™ ser t√£o popular hoje. Ele introduz v√°rias abordagens e estrat√©gias inovadoras para o desenvolvimento sever-side com JavaScript que j√° ajudaram diversos desenvolvedores.

	2009

	 	Nasce o Node.js

	A primeira forma do npm √© criada



	2010

	 	Nasce o Express

	Nasce o Socket.io



	2011

	 	npm alcan√ßa a vers√£o 1.0

	Grandes empresas come√ßam a adotar Node.js: LinkedIn, Uber, etc.

	Nasce o hapi



	2012

	 	Ado√ß√£o continua muito r√°pida



	2013

	 	Primeira grande plataforma de blogs usando Node.js: Ghost

	Nasce o Koa



	2014

	 	O Grande Fork: io.js √© o maior fork do Node.js, com o objetivo de introduzir suporte ao ES6 e crescer rapidamente.



	2015

	 	Nasce a Node.js Foundation

	IO.js √© mergeado de volta ao Node.js

	npm introduz m√≥dulos privados

	Node.js 4 (vers√µes 1, 2 e 3 nunca foram lan√ßadas previamente)



	2016

	 	O incidente de leftpad

	Nasce o Yarn

	Node.js 6



	2017

	 	npm aumenta o foco em seguran√ßa

	Node.js 8

	HTTP/2

	V8 introduz o Node.js em sua suite de testes, fazendo do Node.js oficialmente um alvo da engine, em adi√ß√£o ao Chrome

	3 bilh√µes de downloads no npm toda semana



	2018

	 	Node.js 10

	ES modules: suporte experimental ao .mjs

	Node.js 11



	2019

	 	Node.js 12

	Node.js 13



	2020

	 	Node.js 14

	Node.js 15



	Como instalar o Node.js

	Node.js pode ser instalado de diferentes formas. Esse post destaca as mais comuns e convenientes.

	Pacotes oficiais para todas as principais plataformas est√£o dispon√≠veis em https://nodejs.org/en/download/.

	Uma maneira muito conveniente de instalar o Node.js √© atrav√©s de um gerenciador de pacotes. Neste caso, cada sistema operacional tem sua abordagem mais adequada.

	No macOS, Homebrew √© a alternativa oficial, e - uma vez instalado - permite que a instala√ß√£o do Node.js seja feita facilmente, rodando esse comando na CLI:

	brew install node

	Outros gerenciadores de pacote para Linux e Windows est√£o listados em https://nodejs.org/en/download/package-manager/.

	nvm √© um maneira muito popular de rodar Node.js. Ele permite que voc√™ troque facilmente entre vers√µes, e instale novas vers√µes para testar e troque de volta caso algo pare de funcionar, por exemplo.

	Tamb√©m √© muito √∫til para testar seu c√≥digo com vers√µes antigas do Node.js

	Veja https://github.com/creationix/nvm para mais informa√ß√µes sobre essa op√ß√£o.

	Minha sugest√£o √© utilizar o instalador oficial se voc√™ s√≥ estiver come√ßando e n√£o utiliza o Homebrew, caso contr√°rio, o Homebew √© a minha solu√ß√£o favorita.

	Em todo caso, quando o Node.js √© instalado voc√™ ter√° acesso ao comando execut√°vel node na linha de comando.

	O que devo saber de Javascript para usar o Node.JS?

	Como um iniciante, √© dif√≠cil chegar no ponto onde voc√™ √© confiante o suficiente nas suas habilidades de programa√ß√£o.

	Enquanto aprende a programar, voc√™ tamb√©m pode ficar confuso sobre onde o JavaScript termina, e onde o Node.js come√ßa, e vice versa.

	Eu recomendo que voc√™ tenha um bom dom√≠nio dos principais conceitos do JavaScript antes de mergulhar no Node.js:

	 	Estrutura L√©xica

	Express√µes

	Tipos

	Vari√°veis

	Fun√ß√µes

	this

	Arrow Functions

	Loops

	Escopos

	Arrays

	Template Literals

	Semicolons (;)

	Strict Mode

	ECMAScript 6, 2016, 2017



	Com esses conceitos em mente, voc√™ est√° no caminho certo para se tornar um desenvolvedor proficiente em JavaScript, tanto Browser como tamb√©m Node.js.

	Os conceitos a seguir tamb√©m s√£o essenciais para entender programa√ß√£o ass√≠ncrona, que √© uma parte fundamental do Node.js:

	 	Programa√ß√£o Ass√≠ncrona e callbacks

	Timers

	Promises

	Async e Await

	Closures

	Event Loop



	Qual a diferen√ßa do Node.JS e do Browser?

	Ambos browser e Node.js utilizam JavaScript como sua linguagem de programa√ß√£o.

	Construir aplica√ß√µes que rodem no browser √© uma coisa completamente diferente de construir aplica√ß√µes Node.js

	Apesar do fato que √© sempre JavaScript, h√° fatores chave que tornam a experi√™ncia radicalmente diferente.

	Da perspectiva de um desenvolvedor frontend que usa JavaScript extensivamente, aplica√ß√µes Node.js trazem consigo uma enorme vantagem: o conforto de programar tudo - o frontend e o backend - em uma √∫nica linguagem.

	Voc√™ tem uma grande oportunidade porque n√≥s sabemos qu√£o dif√≠cil √© para aprender, completa e profundamente, uma nova linguagem de programa√ß√£o, e por usar a mesma linguagem para fazer todo o trabalho na web - tanto no servidor quanto no cliente, voc√™ est√° em uma posi√ß√£o √∫nica de vantagem.

	O que muda √© o ecossistema.

	No browser, na maioria do tempo o que voc√™ est√° fazendo √© interagindo com o DOM, ou outras APIs Web como Cookies. Isso n√£o existe no Node.js, √© claro. Voc√™ n√£o tem o document, window e todos os outros objetos que s√£o providos pelo browser.

	E no browser, n√≥s n√£o temos as APIs legais que o Node.js prov√™ com seus m√≥dulos, como a funcionalidade de acesso ao filesystem.

	Outra grande diferen√ßa √© que no Node.js voc√™ controla seu ambiente. A n√£o ser que voc√™ esteja criando uma aplica√ß√£o open source que qualquer um pode hospedar em qualquer lugar, voc√™ sabe em qual vers√£o do Node.js a aplica√ß√£o vai rodar. Comparado ao ambiente do browser, onde voc√™ n√£o tem o luxo de escolher qual browser seu visitante vai utilizar, isso √© muito conveniente.

	Isso significa que voc√™ pode escrever c√≥digos com os modernos ES6-7-8-9, se atentando ao suporte da sua vers√£o do Node.js.

	Visto que o JavaScript se move muito r√°pido, mas os browsers podem ser um pouco lentos para atualizarem, as vezes na web, voc√™ est√° preso em vers√µes velhas do JavaScript / ECMAScript.

	Voc√™ pode utilizar o Babel para transformar seu c√≥digo em um formato comp√°tivel com ES5 antes de enviar para o browser, mas no Node.js, voc√™ n√£o precisa disso.

	Outra diferen√ßa √© que o Node.js utiliza o sistema de m√≥dulos CommonJS, enquanto que nos browsers ainda estamos vendo o inicio da implementa√ß√£o do padr√£o ES Modules.

	Na pr√°tica, isso signifca que por enquanto voc√™ utiliza require() no Node.js e import no browser.

	O motor V8 do JAvascript

	V8 √© o nome da engine JavaScript que roda no Google Chrome. √â a coisa que pega nosso JavaScript e o executa enquanto navegamos com o Chrome.

	V8 prov√™ o ambiente de execu√ß√£o em que o JavaScript executa. O DOM, e outras APIs web s√£o fornecidas pelo browser.

	O legal √© que a engine JavaScript √© independente do browser que ela est√° hospedada. Essa funcionalidade chave possibilitou a ascens√£o do Node.js. A V8 foi escolhida como engine por tr√°s do Node.js em 2009, e com a explos√£o de popularidade do Node.js, a V8 se tornou a engine que agora possibilita uma quantidade incr√≠vel de c√≥digo sever-side escrito em JavaScript.

	O ecossistema Node.js √© enorme e isso gra√ßas √† V8 que tamb√©m possibilitou aplica√ß√µes desktop, com projetos como o Electron.

	Outras engines JS

	Outros browsers t√™m suas pr√≥pias engines:

	 	Firefox tem a SpiderMonkey

	Safari tem a JavaScriptCore (tamb√©m chamada de Nitro)

	Edge foi originalmente basedo na Chakra mas recentemente foi refeito utilizando Chromium e a V8.



	e existem muitas outras tamb√©m.

	Todas essas engines implementam o padr√£o ECMA ES-262, tamb√©m chamado de ECMAScript, o padr√£o utilizado pelo JavaSript.

	A busca por performance

	V8 foi escrita em C++, e √© continuamente melhorada. √â port√°vel e roda no Mac, Windows, Linux e diversos outros sistemas.

	Nessa introdu√ß√£o √† V8, vamos ignorar os detalhes de implementa√ß√£o: eles podem ser encontrados em sites mais apropriados (por exemplo, o site oficial da V8), e eles mudam com o passar do tempo, frequentemente.

	V8 est√° sempre evoluindo, assim como as outras engines JavaScript ao seu redor, para agilizar a Web e o ecossistema Node.js.

	Na web, h√° uma corrida por performance que vem sendo travada por anos, e n√≥s (como usu√°rios e desenvolvedores) nos beneficiamos muito por essa competi√ß√£o, porque n√≥s possu√≠mos m√°quinas mais r√°pidas e otimizadas ano a ano.

	Compila√ß√£o

	JavaScript √© geralmente considerado como uma linguagem interpretada, mas engines modernas de JavaScript n√£o o interpretam apenas, elas o compilam.

	Isso vem acontecendo desde 2009, quando o compilador JavaScript SpiderMonkey foi adicionado no Firefox 3.5, e todo mundo seguiu essa ideia.

	JavaScript √© internamente compilado pela v8 com compila√ß√£o just-in-time (JIT) para acelerar a execu√ß√£o.

	Isso pode parecer contra-intuitivo, mas desde a introdu√ß√£o do Google Maps em 2004, o JavaScript evoluiu de uma linguagem que geralmente executava poucas d√∫zias de linhas de c√≥digo, para aplica√ß√µes completas com centenas de milhares de linhas de c√≥digo executando no browser.

	Nossas aplica√ß√µes agora podem rodar por horas dentro do browser, em vez de uma simples valida√ß√£o de regras de formul√°rios ou scripts banais.

	Nesse novo mundo, compilar JavaScript faz total sentido porque, embora possa demorar um pouco mais para termos o c√≥digo JavaScript pronto, uma vez conclu√≠da a compila√ß√£o temos muito mais desempenho do que c√≥digo puramente interpretado.

	Rode scripts do Node a partir da linha de comando do Linux

	A maneira mais usual de rodar um programa Node.js √© executando o comando node dispon√≠vel globalmente (uma vez instalado o Node.js) e passando o nome do arquivo desejado.

	Considerando que o arquivo principal da sua aplica√ß√£o Node.js se chame app.js, voc√™ pode execut√°-lo digitando:

	node app.js

	Enquanto executa o comando, tenha certeza de estar no mesmo diret√≥rio que cont√™m o arquivo app.js.

	Como sair de um programa Node.JS

	H√° v√°rias maneiras de finalizar uma aplica√ß√£o Node.js.

	Com o programa rodando no console, voc√™ pode fech√°-lo com ctrl-C, mas o que queremos discutir aqui √© a maneira program√°tica de fazer isso.

	Vamos come√ßar com a maneira mais dr√°stica, e note porque √© melhor voc√™ n√£o utiliz√°-la:

	O m√≥dulo nativo process prov√™ um m√©todo pr√°tico que permite a voc√™, programaticamente, sair de um programa Node.js: process.exit().

	Quando o Node.js executa essa linha, o processo √© for√ßado a terminar imediatamente.

	Isso significa que qualquer callback pendente, qualquer request de rede sendo enviada, qualquer acesso ao filesystem, ou processos de escrita no stdout ou stderr - tudo ser√° finalizado de imediato desgraciadamente.

	Se isso est√° bem para voc√™, basta passar um inteiro que sinalize o c√≥digo de sa√≠da para o sistema operacional:

	process.exit(1)

	Por padr√£o, o c√≥digo de sa√≠da √© 0, que significa sucesso. C√≥digos de sa√≠da diferentes tem significados diferentes, que voc√™ pode querer utilizar no seu sistema para se comunicar com outros programas.

	Voc√™ pode ler mais sobre os c√≥digos de sa√≠da em https://nodejs.org/api/process.html#process_exit_codes;

	Voc√™ tamb√©m pode definir a propriedade process.exitCode como:

	process.exitCode = 1

	e quando o programa for encerrado posteriormente, o Node.js retornar√° esse c√≥digo de sa√≠da.

	Um programa ir√° sair graciosamente quando todos os processos estiverem completos.

	Muitas vezes n√≥s iniciamos servidores Node.js, como esse servidor HTTP:

	const express = require('express')

	const app = express()



	app.get('/', (req, res) => {

	 res.send('Hi!')

	})



	app.listen(3000, () => console.log('Server ready'))

	Esse programa nunca ter√° um fim. Se voc√™ chamar process.exit(), qualquer requisi√ß√£o corrente/pendente ser√° abortada. Isso n√£o √© legal.

	Nesse caso, voc√™ precisa enviar ao comando um sinal de SIGTERM, e lidar com o processo desse sinal:

	Nota: process n√£o requer importa√ß√£o, est√° dispon√≠vel automaticamente.

	const express = require('express')



	const app = express()



	app.get('/', (req, res) => {

	 res.send('Hi!')

	})



	const server = app.listen(3000, () => console.log('Server ready'))



	process.on('SIGTERM', () => {

	 server.close(() => {

	 console.log('Process terminated')

	 })

	})

	O que s√£o sinais? Sinais s√£o um sistema de intercomunica√ß√£o POSIX: uma notifica√ß√£o enviada para um processo com o objetivo de notificar que um evento ocorreu.

	 	SIGKILL √© o sinal que diz ao processo para que finalize imediatamente, e agir√° idealmente como o process.exit().

	SIGTERM √© o sinal que diz ao processo para que termine graciosamente. √â o sinal que √© enviado por generenciadores de processo como upstart ou supervisord e muitos outros.



	Voc√™ pode enviar esse sinal por dentro da aplica√ß√£o, em outra fun√ß√£o:

	process.kill(process.pid, 'SIGTERM')

	ou de outro programa Node.js em execu√ß√£o, ou qualquer outra aplica√ß√£o rodando em seu sistema que saiba o PID do processo que voc√™ deseja fianlizar.

	Como ler Vari√°veis de ambiente a partir do Node.js?

	O m√≥dulo nativo process do Node.js fornece a propriedade env que armazena todas as vari√°veis de ambiente que foram definidas no momento de in√≠cio da aplica√ß√£o.

	Aqui vai um exemplo que acessa a vari√°vel de ambiente NODE_ENV, que √© definida com o valor development por padr√£o.

	Nota: process n√£o requer importa√ß√£o, est√° dispon√≠vel automaticamente.

	process.env.NODE_ENV // "development"

	Defini-l√° para ‚Äúproduction‚Äù antes do script executar contar√° ao Node.js que √© um ambiente de produ√ß√£o.

	Da mesma forma, voc√™ pode acessar/definir qualquer vari√°vel de ambiente customizada.

	Como usar o REPL no Node

	N√≥s usamos o comando node para executar scripts Node.js:

	node script.js

	Se n√≥s omitirmos o nome do arquivo, iniciaremos o modo REPL:

	node

	Nota: REPL (Read Evaluate Print Loop) √© um ambiente para linguagem de programa√ß√£o (basicamente uma aba de console) que l√™ instru√ß√µes individuais do input do usu√°rio e ap√≥s a execu√ß√£o, retorna o resultado no console.

	Se voc√™ tentar isso agora no seu terminal, isto √© o que vai acontecer:

	‚ùØ node

	>

	o comando permanece em modo de espera (idle) e aguarda alguma entrada.

	Dica: se voc√™ n√£o tem certeza de como abrir seu terminal, pesquise por ‚ÄúHow to open terminal on <seu SO>‚Äú.

	Para ser mais exato, o REPL est√° aguardando a entrada de c√≥digo JavaScript.

	Vamos come√ßar de forma simples:

	> console.log('test')

	test

	undefined

	>

	O primeiro valor, test, √© a sa√≠da que esperavamos do log do console, e depois tivemos um undefined, que √© o retorno de rodar console.log().

	Agora podemos inserir uma nova entrada de JavaScript.

	Use o tab para autocomplete

	O legal do REPL √© que ele √© interativo.

	Conforme voc√™ escreve seu c√≥digo, se voc√™ pressionar o tecla tab o REPL vai tentar completar o que foi escrito para combinar com vari√°veis previamente definidas.

	Explorando objetos do JavaScript

	Tente digitar o nome de uma classe do JavaScript, como Number, e adicione um ponto e pressione tab.

	O REPL vai listar todas as propriedades e m√©todos que voc√™ pode acessar naquela classe:



	Explore objetos globais

	Voc√™ pode inspecionar os objetos globais que voc√™ tem acesso digitando global. e pressionando tab:



	A vari√°vel especial _

	Se depois de um c√≥digo voc√™ digitar _, isso far√° com que seja exibido o resultado da √∫ltima opera√ß√£o.

	Comandos com ponto (dot commands)

	O REPL tem alguns comandos especiais, todos come√ßando com um .. Eles s√£o:

	 	.help: exibe a guia de ajuda dos dot commands.

	.editor: habilita o modo de editor, para escrever m√∫ltiplas linhas de c√≥digo JavaScript com facilidade. Uma vez nesse modo, pressione ctrl-D para executar o c√≥digo que foi escrito.

	.break: quando estiver inserindo um c√≥digo com m√∫ltiplas linhas, utilizar o comando .break far√° com que a entrada seja abortada. Mesma funcionalidade de pressionar ctrl-C.

	.clear: reinicia o contexto do REPL para um objeto vazio e cancela qualquer entrada corrente de m√∫ltiplas linhas.

	.load: carrega um arquivo JavaScript, relativo ao diret√≥rio atual.

	.save: salva todas suas entradas na sess√£o REPL em um arquivo (especifique um nome pro arquivo)

	.exit: sai do repl (mesmo funcionamento de pressionar ctrl-C duas vezes)



	O REPL sabe quando voc√™ est√° inserindo uma entrada com m√∫ltiplas linhas sem a necessidade de utilizar o .editor.

	Por exemplo, se voc√™ come√ßar a digitar uma itera√ß√£o como essa:

	[1, 2, 3].forEach(num => {

	e pressionar enter, o REPL ir√° para uma nova linha que come√ßa com 3 pontos, indicando que voc√™ pode continuar a trabalhar naquele bloco.

	... console.log(num)

	... })

	Se voc√™ digitar .break no fim de uma linha, o modo m√∫ltiplas linhas ir√° parar e o c√≥digo n√£o ser√° executado.

	O Node.JS aceita argumentos a partir da linha de comando.

	Voc√™ pode passar qualquer quantidade de argumentos quando est√° invocando uma aplica√ß√£o Node.js, usando:

	node app.js

	Argumentos podem ser com chave e valor ou diretos (sem chave).

	Por exemplo:

	node app.js joe

	ou

	node app.js name=joe

	Isso muda em como voc√™ obter√° os valores no c√≥digo Node.js.

	A maneira de obt√™-los √© usando o objeto nativo process.

	Ele exp√µe uma propriedade chamada argv, que √© um array que cont√™m todos os argumentos passados na invoca√ß√£o.

	O primeiro elemento √© o caminho absoluto do comando node.

	O segundo √© o caminho absoluto do arquivo em execu√ß√£o.

	Todos os argumentos adicionais est√£o presentes da terceira posi√ß√£o em diante.

	Voc√™ pode iterar sobre todos os argumentos (incluindo o caminho do node e o do arquivo) usando um loop:

	process.argv.forEach((val, index) => {

	 console.log(`${index}: ${val}`)

	})

	ou obter apenas os argumentos adicionais, criando um novo array que exclui os 2 primeiros par√¢metros:

	const args = process.argv.slice(2)

	Se voc√™ tem um argumento direto (sem chave), como esse:

	node app.js joe

	voc√™ pode acess√°-lo usando

	const args = process.argv.slice(2)

	args[0]

	J√° nesse caso:

	node app.js name=joe

	args[0] √© name=joe, e voc√™ precisa trat√°-lo. A melhor maneira de fazer isso √© usando a biblioteca minimist, que ajuda a lidar com argumentos:

	const args = require('minimist')(process.argv.slice(2))

	args['name'] //joe

	Desta vez voc√™ voc√™ precisa usar dois tra√ßos antes do nome do argumento:

	node app.js --name=joe

	Output para a linha de comando usando Node.JS

	Sa√≠da (output) b√°sico usando o m√≥dulo console

	O Node.js prov√™ o m√≥dulo console que possui uma infinidade de maneiras muito √∫teis para interagir com a linha de comando.

	√â basicamente o mesmo objeto console encontrado no browser.

	O m√©todo mais b√°sico e mais usado √© o console.log(), que imprime a string que voc√™ passar como par√¢metro.

	Se voc√™ passar um objeto, ele ir√° renderiz√°-lo como uma string.

	Voc√™ pode passar m√∫ltiplas vari√°veis para o console.log, por exemplo:

	const x = 'x'

	const y = 'y'

	console.log(x, y)

	o Node.js vai printar ambas.

	N√≥s tamb√©m podemos formatar mensagens mais sofisticadas passando vari√°veis e um formato espeficador.

	Por exemplo:

	console.log('My %s has %d years', 'cat', 2)

	 	%s formata a vari√°vel como uma string

	%d formata a vari√°vel como um n√∫mero

	%i formata a vari√°vel como um n√∫mero, por√©m s√≥ a parte inteira

	%o formata a vari√°vel como um objeto



	Exemplo:

	console.log('%o', Number)

	Limpando o console

	console.clear() limpa o console (o comportamento pode mudar dependendo do console utilizado).

	Contando elementos

	console.count() √© um m√©todo muito conveniente.

	Dado o c√≥digo:

	const x = 1

	const y = 2

	const z = 3

	console.count(

	 'O valor de x √© ' + x + ' e foi validado .. quantas vezes?'

	)

	console.count(

	 'O valor de x √© ' + x + ' e foi validado .. quantas vezes?'

	)

	console.count(

	 'O valor de y √© ' + y + ' e foi validado .. quantas vezes?'

	)

	O que acontece √© que ele vai contar o n√∫mero de vezes que uma string foi impressa, e imprime o total:

	Voc√™ pode contar ma√ß√£s e laranjas, por exemplo:

	const oranges = ['orange', 'orange']

	const apples = ['just one apple']

	oranges.forEach(fruit => {

	 console.count(fruit)

	})

	apples.forEach(fruit => {

	 console.count(fruit)

	})

	Imprimindo a pilha de execu√ß√£o

	Existem casos onde √© √∫til imprimir a pilha de execu√ß√£o da fun√ß√£o, talvez para responder a cl√°ssica pergunta como voc√™ chegou nessa parte do c√≥digo?

	Voc√™ pode isso fazer usando console.trace():

	const function2 = () => console.trace()

	const function1 = () => function2()

	function1()

	Isso ir√° imprimir a pilha de execu√ß√£o. Isso √© o que √© impresso se tentarmos us√°-lo no REPL do Node.js:

	Trace

	 at function2 (repl:1:33)

	 at function1 (repl:1:25)

	 at repl:1:1

	 at ContextifyScript.Script.runInThisContext (vm.js:44:33)

	 at REPLServer.defaultEval (repl.js:239:29)

	 at bound (domain.js:301:14)

	 at REPLServer.runBound [as eval] (domain.js:314:12)

	 at REPLServer.onLine (repl.js:440:10)

	 at emitOne (events.js:120:20)

	 at REPLServer.emit (events.js:210:7)

	Calculando o tempo gasto

	Voc√™ pode calcular facilmente o tempo que uma fun√ß√£o gasta para rodar, usando time() e timeEnd()

	const doSomething = () => console.log('test')

	const measureDoingSomething = () => {

	 console.time('doSomething()')

	 //fa√ßa algo, e calcule o tempo que isso levou

	 doSomething()

	 console.timeEnd('doSomething()')

	}

	measureDoingSomething()

	stdout e stderr

	Como n√≥s vimos o console.log √© √≥timo para imprimir mensagens no console. Isso √© o que chamamos de sa√≠da padr√£o, ou stdout.

	console.error imprime na stream stderr.

	Isso n√£o vai aparecer no console, mas vai aparecer no log de erro.

	Colorindo o sa√≠da

	Voc√™ pode colorir a sa√≠da do seu texto no console utilizando escape sequences, que basicamente s√£o um conjunto de caracteres que indentificam uma cor.

	Exemplo:

	console.log('\x1b[33m%s\x1b[0m', 'hi!')

	Voc√™ pode testar isso no REPL no Node.js, onde ser√° impresso hi! em amarelo.

	Entretanto, essa √© uma abordagem mais baixo n√≠vel. O jeito mais simples de colorir sa√≠das no console √© utilizando uma biblioteca. Chalk √© uma biblioteca que al√©m de colorir, tamb√©m ajuda com outras facilidades de estiliza√ß√£o, como deixar textos em negrito, √≠talico ou sublinhados.

	Instale com npm install chalk, e ent√£o use-o assim:

	const chalk = require('chalk')

	console.log(chalk.yellow('hi!'))

	Usando chalk.yellow √© muito mais conveniente do que tentar lembrar o c√≥digo de cor correto, e o c√≥digo fica muito mais leg√≠vel.

	Confira o link do projeto postado acima para mais exemplos de uso.

	Crie uma barra de progresso

	Progress √© um pacote incr√≠vel para criar uma barra de progresso no console. Instale utilizando npm install progress.

	Esse trecho cria uma barra de progresso com 10 passos, e a cada 100ms um passo √© completado. Quando a barra √© completada n√≥s finalizamos o contador.

	const ProgressBar = require('progress')



	const bar = new ProgressBar(':bar', { total: 10 })

	const timer = setInterval(() => {

	 bar.tick()

	 if (bar.complete) {

	 clearInterval(timer)

	 }

	}, 100)

	Aceite inputs do terminal no Node.js

	Como criar um programa Node.js de CLI interativa?

	Desde a vers√£o 7 o Node.js possui o m√≥dulo readline para fazer exatamente isso: obter entradas de uma stream de leitura, como a process.stdin, via terminal, durante a execu√ß√£o de um programa Node.js, uma linha por vez.

	const readline = require('readline').createInterface({

	 input: process.stdin,

	 output: process.stdout

	})



	readline.question(`What's your name?`, name => {

	 console.log(`Hi ${name}!`)

	 readline.close()

	})

	Esse trecho de c√≥digo pergunta o nome do usu√°rio, e uma vez que o texto √© inserido e o usu√°rio pressiona enter, n√≥s enviamos uma sauda√ß√£o.

	O m√©todo question() exibe o primeiro par√¢metro (a pergunta) e aguarda pela entrada do usu√°rio. A fun√ß√£o de callback √© invocada uma vez que o enter √© pressionado.

	Nessa fun√ß√£o de callback, n√≥s fechamos a interface do readline.

	readline oferece diversos outros m√©todos, e voc√™ pode conferir todos na documenta√ß√£o linkada acima.

	Se voc√™ precisa solicitar uma senha, o ideal √© que os caracteres digitados sejam trocados pelo s√≠mbolo de *.

	A maneira mais simples de fazer isso √© utilizar o pacote readline-sync, que √© muito similar em termos de API.

	Outra solu√ß√£o mais completa e abstrata √© fornecida pelo pacote Inquirer.js.

	Instale-o utilizando npm install inquirer, e ent√£o voc√™ poder√° replicar o c√≥digo acima dessa forma:

	const inquirer = require('inquirer')



	var questions = [

	 {

	 type: 'input',

	 name: 'name',

	 message: "What's your name?"

	 }

	]



	inquirer.prompt(questions).then(answers => {

	 console.log(`Hi ${answers['name']}!`)

	})

	Inquirer.js permite com que voc√™ fa√ßa diversas coisas como perguntas de m√∫ltipla escolha, ter radio buttons, confirma√ß√µes e muito mais.

	Vale a pena conhecer todas as alternativas, especialmente as nativas do Node.js, mas se voc√™ planeja levar a CLI para outro n√≠vel, Inquirer.js √© √≥tima escolha.

	Expondo uma funcionalidade em um arquivo do Node.js usando exports

	O Node.js tem um sistema de m√≥dulos nativo.

	Um arquivo Node.js pode importar funcionalidades expostas por outros arquivos Node.js.

	Quando voc√™ quer importar algo voc√™ deve utilizar

	const library = require('./library')

	para importar a funcionalidade exposta no arquivo library.js que reside na pasta atual.

	Nesse arquivo, a funcionalidade deve ser exposta antes de poder ser importada por outros arquivos.

	Qualquer outra vari√°vel ou objeto definido no arquivo √© privado por padr√£o e n√£o exposto ao mundo exterior.

	Isso √© permitido por meio da API module.exports, oferecida pelo module system.

	Quando voc√™ atribui um objeto ou uma fun√ß√£o como uma nova propriedade do exports, isso se torna o que est√° sendo exposto, e como tal, pode ser importado em outras partes da sua aplica√ß√£o, ou at√© em outras aplica√ß√µes.

	Voc√™ pode fazer isso de 2 formas.

	A primeira √© atribuir um objeto ao module.exports, que √© um objeto provido nativamente pelo sistema de m√≥dulos, e ele far√° com que o arquivo exporte apenas aquele objeto:

	const car = {

	 brand: 'Ford',

	 model: 'Fiesta'

	}



	module.exports = car



	//..em outro arquivo



	const car = require('./car')

	A segunda √© definir o objeto exportado como propriedade do exports. Essa abordagem permite que voc√™ exporte m√∫ltiplos objetos, fun√ß√µes ou dados:

	const car = {

	 brand: 'Ford',

	 model: 'Fiesta'

	}



	exports.car = car

	ou diretamente

	exports.car = {

	 brand: 'Ford',

	 model: 'Fiesta'

	}

	Em outro arquivo, voc√™ ir√° utiliz√°-lo referenciando a propriedade da sua importa√ß√£o:

	const items = require('./items')

	items.car

	ou

	const car = require('./items').car

	Qual a diferen√ßa entre module.exports e exports?

	O primeiro exp√µe o objeto para qual ele aponta. O √∫ltimo exp√µe as propriedades do objeto que ele aponta.

	Uma introdu√ß√£o ao gerenciador de pacotes NPM

	Introdu√ß√£o ao npm

	npm √© o gerenciador de pacotes padr√£o do Node.js.

	Em janeiro de 2017 mais de 350.000 pacotes foram listados no registro do npm, fazendo dele o maior reposit√≥rio de c√≥digo de uma √∫nica linguagem na Terra, e voc√™ pode ter certeza que existe um pacote para (quase!) tudo.

	Ele iniciou como um meio de fazer donwload e gerenciar depend√™ncias de pacotes Node.js, mas desde ent√£o ele se tornou uma ferramenta utilizada tamb√©m no frontend.

	H√° muitas coisas que o npm faz.

	Yarn √© uma alternativa ao npm. N√£o deixe de confer√≠r.

	Downloads

	npm gerencia downloads de depend√™ncias do seu projeto.

	Instalando todas depend√™ncias

	Se o projeto tem um arquivo package.json, ao rodar

	npm install

	ele vai instalar tudo que o projeto precisa, na pasta node_modules, criando-a se n√£o existir.

	Instalando um √∫nico pacote

	Voc√™ tamb√©m pode instalar um pacote espec√≠fico ao rodar

	npm install <package-name>

	Geralmente voc√™ ver√° mais flags adicionadas a esse comando:

	 	--save instala e adiciona uma entrada no campo dependencies do arquivo package.json

	--save-dev instala e adiciona uma entrada no campo devDependencies do arquivo package.json



	A principal diferen√ßa √© que no devDependencies ficam as ferramentas de desenvolvimento, como uma biblioteca de testes, enquanto no dependencies ficam os pacotes necess√°rios √† aplica√ß√£o em ambiente de produ√ß√£o.

	Atualizando pacotes

	Atualizar tamb√©m √© f√°cil, ao rodar

	npm update

	o npm vai buscar em todos os pacotes por uma vers√£o atualizada que satisfa√ßa suas restri√ß√µes de versionamento.

	Voc√™ tamb√©m pode especificar um √∫nico pacote para atualizar:

	npm update <package-name>

	Versionamento

	Em adi√ß√£o aos downloads, o npm tamb√©m gerencia o versionamento, assim voc√™ pode especificar qualquer vers√£o do pacote, ou uma vers√£o maior ou menor do que voc√™ precisa.

	Muitas vezes voc√™ vai encontrar uma biblioteca que s√≥ √© compat√≠vel com a vers√£o atual de outra biblioteca.

	Ou um bug na vers√£o mais atual da biblioteca, ainda n√£o solucionado, causando um problema.

	Especificar explicitamente a vers√£o da biblioteca tamb√©m ajuda a manter todos na exata mesma vers√£o do pacote, assim todos do time rodam a mesma vers√£o at√© que o arquivo package.json seja atualizado.

	Em todos os casos, versionar ajuda muito, e o npm segue o padr√£o sem√¢ntico de versionamento chamado semver.

	Executando tarefas

	O arquivo package.json possui um campo chamado ‚Äúscripts‚Äù, que √© usado para especificar tarefas de linha de comando que podem ser rodadas usando

	npm run <task-name>

	Por exemplo:

	{

	 "scripts": {

	 "start-dev": "node lib/server-development",

	 "start": "node lib/server-production"

	 },

	}

	√â muito comum usar esse recurso para rodar o Webpack:

	{

	 "scripts": {

	 "watch": "webpack --watch --progress --colors --config webpack.conf.js",

	 "dev": "webpack --progress --colors --config webpack.conf.js",

	 "prod": "NODE_ENV=production webpack -p --config webpack.conf.js",

	 },

	}

	Ent√£o em vez de digitar esses comandos longos, que s√£o muito f√°ceis de errar ou esquecer, voc√™ pode rodar

	npm run watch

	npm run dev

	npm run prod

	Onde o Node instala os pacotes?

	Quando voc√™ instala um pacote utilizando npm voc√™ pode executar 2 tipos de instala√ß√£o:

	 	local

	global



	Por padr√£o, quando voc√™ digita o comando npm install, como por exemplo:

	npm install lodash

	o pacote ser√° instalado na √°rvore de arquivos atual, em uma subpasta dentro da node_modules.

	Quando isso ocorre, o npm tamb√©m adiciona uma entrada do lodash na propriedade dependencies do arquivo package.json da pasta atual.

	Para executar uma instala√ß√£o global, basta utilizar a flag -g:

	npm install -g lodash

	Quando isso ocorre, o npm n√£o instalar√° na pasta local, em vez disso, ele utilizar√° uma localiza√ß√£o global.

	Onde, exatamente?

	O comando npm root -g te dir√° a localiza√ß√£o exata na sua m√°quina.

	No macOS ou Linux, essa localiza√ß√£o costuma ser /usr/local/lib/node_modules. No Windows costuma ser C:\Users\YOU\AppData\Roaming\npm\node_modules

	Todavia, se voc√™ utiliza o nvm para gerenciar vers√µes do Node.js, a localiza√ß√£o pode ser diferente.

	Eu por exemplo utilizo nvm e a localiza√ß√£o dos meus pacotes foi exibida como /Users/joe/.nvm/versions/node/v8.9.0/lib/node_modules.

	Como usar ou executar um pacote instalado usando NPM?

	Quando voc√™ instala um pacote usando npm dentro da sua pasta node_modules, ou tamb√©m globamente, como voc√™ o utiliza em seu c√≥digo Node.js?

	Digamos que voc√™ instale a famosa biblioteca JavaScript de utilidades chamada lodash, usando

	npm install lodash

	Isso ir√° instalar o pacote na sua pasta node_modules local.

	Para utiliz√°-lo em seu c√≥digo, voc√™ s√≥ precisa import√°-lo no seu programa utilizando require:

	const _ = require('lodash')

	Mas e se o seu pacote for um execut√°vel?

	Nesse caso, ele para a pasta node_modules/.bin/.

	Um jeito f√°cil de demonstrar isso √© utilizando o cowsay.

	O pacote cowsay fornece um programa de linha de comando que faz com que uma vaca diga algo (e outros animais tamb√©m ü¶ä).

	Quando voc√™ instala o pacote utilizando npm install cowsay, ele ir√° instalar a si mesmo e algumas poucas depend√™ncias na sua pasta node_modules local:



	H√° uma pasta oculta chamada .bin, que cont√™m links simb√≥licos para os bin√°rios do cowsay:



	Como voc√™ executa isso?

	√â claro que voc√™ pode digitar ./node_modules/.bin/cowsay para executar, e vai funcionar, mas o npx, incluso nas vers√µes recentes do npm (desde a 5.2), √© uma op√ß√£o muito melhor. Voc√™ s√≥ roda:

	npx cowsay

	e o npx vai encontrar a localiza√ß√£o do pacote.



	O Guia do package.json

	Se voc√™ trabalha com JavaScript, ou j√° interagiu com um projeto JavaScript, Node.js ou um projeto frontend, voc√™ certamente conheceu o arquivo package.json.

	Pra que ele serve? O que voc√™ deveria saber sobre ele, e o qu√™ de legal pode ser feito com ele?

	O package.json √© uma esp√©cie de manifesto do seu projeto. Ele pode fazer uma variedade de coisas, completamente n√£o relacionadas. √â um reposit√≥rio central de configura√ß√µes para ferramentas, por exemplo. Tamb√©m √© onde o npm e o yarn armazenam os nomes e vers√µes de todos os pacotes instalados.

	The file structure

	Aqui temos um exemplo de arquivo package.json:

	{}

	Est√° vazio! N√£o h√° campos fixos obrigat√≥rios do que pode ser colocado no arquivo package.json, de uma aplica√ß√£o. A √∫nica exig√™ncia √© que respeite o formato JSON, caso contr√°rio programas que tentem acessar as propriedades programaticamente n√£o ter√£o sucesso.

	Se voc√™ est√° criando um pacote Node.js que precisa ser distribuido no npm as coisas mudam radicalmente, e voc√™ necessita preencher algumas propriedades que v√£o ajudar outras pessoas a utilizar seu pacote. Vamos ver mais sobre isso em breve.

	Esse √© outro package.json:

	{

	 "name": "test-project"

	}

	Ele define uma propriedade name, que diz o nome da aplica√ß√£o, ou pacote, que est√° contido na mesma pasta em que o arquivo reside.

	Aqui temos outro exemplo muito mais complexo, que foi extraido de uma aplica√ß√£o Vue.js:

	{

	 "name": "test-project",

	 "version": "1.0.0",

	 "description": "A Vue.js project",

	 "main": "src/main.js",

	 "private": true,

	 "scripts": {

	 "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",

	 "start": "npm run dev",

	 "unit": "jest --config test/unit/jest.conf.js --coverage",

	 "test": "npm run unit",

	 "lint": "eslint --ext .js,.vue src test/unit",

	 "build": "node build/build.js"

	 },

	 "dependencies": {

	 "vue": "^2.5.2"

	 },

	 "devDependencies": {

	 "autoprefixer": "^7.1.2",

	 "babel-core": "^6.22.1",

	 "babel-eslint": "^8.2.1",

	 "babel-helper-vue-jsx-merge-props": "^2.0.3",

	 "babel-jest": "^21.0.2",

	 "babel-loader": "^7.1.1",

	 "babel-plugin-dynamic-import-node": "^1.2.0",

	 "babel-plugin-syntax-jsx": "^6.18.0",

	 "babel-plugin-transform-es2015-modules-commonjs": "^6.26.0",

	 "babel-plugin-transform-runtime": "^6.22.0",

	 "babel-plugin-transform-vue-jsx": "^3.5.0",

	 "babel-preset-env": "^1.3.2",

	 "babel-preset-stage-2": "^6.22.0",

	 "chalk": "^2.0.1",

	 "copy-webpack-plugin": "^4.0.1",

	 "css-loader": "^0.28.0",

	 "eslint": "^4.15.0",

	 "eslint-config-airbnb-base": "^11.3.0",

	 "eslint-friendly-formatter": "^3.0.0",

	 "eslint-import-resolver-webpack": "^0.8.3",

	 "eslint-loader": "^1.7.1",

	 "eslint-plugin-import": "^2.7.0",

	 "eslint-plugin-vue": "^4.0.0",

	 "extract-text-webpack-plugin": "^3.0.0",

	 "file-loader": "^1.1.4",

	 "friendly-errors-webpack-plugin": "^1.6.1",

	 "html-webpack-plugin": "^2.30.1",

	 "jest": "^22.0.4",

	 "jest-serializer-vue": "^0.3.0",

	 "node-notifier": "^5.1.2",

	 "optimize-css-assets-webpack-plugin": "^3.2.0",

	 "ora": "^1.2.0",

	 "portfinder": "^1.0.13",

	 "postcss-import": "^11.0.0",

	 "postcss-loader": "^2.0.8",

	 "postcss-url": "^7.2.1",

	 "rimraf": "^2.6.0",

	 "semver": "^5.3.0",

	 "shelljs": "^0.7.6",

	 "uglifyjs-webpack-plugin": "^1.1.1",

	 "url-loader": "^0.5.8",

	 "vue-jest": "^1.0.2",

	 "vue-loader": "^13.3.0",

	 "vue-style-loader": "^3.0.1",

	 "vue-template-compiler": "^2.5.2",

	 "webpack": "^3.6.0",

	 "webpack-bundle-analyzer": "^2.9.0",

	 "webpack-dev-server": "^2.9.1",

	 "webpack-merge": "^4.1.0"

	 },

	 "engines": {

	 "node": ">= 6.0.0",

	 "npm": ">= 3.0.0"

	 },

	 "browserslist": ["> 1%", "last 2 versions", "not ie <= 8"]

	}

	h√° muitas coisas rolando aqui:

	 	version indica a vers√£o atual

	name define o nome da aplica√ß√£o

	description √© uma breve descri√ß√£o da aplica√ß√£o

	main define o ponto de entrada da aplica√ß√£o

	private se definido como true, previne da aplica√ß√£o ser publicada acidentalmente no npm

	scripts define alguns scripts node que voc√™ pode rodar na linha de comando

	dependencies define uma lista de pacotes npm instalados como depend√™ncias

	devDependencies define uma lista de pacotes npm instalados como depend√™ncias de desenvolvimento

	engines define em quais vers√µes do Node.js essa aplica√ß√£o funciona

	browserslist √© usado para definir quais browsers (e suas vers√µes) voc√™ quer dar suporte



	Todas essas propriedades s√£o usadas tanto pelo npm quando outras ferramentas.

	Separa√ß√£o de propriedades

	Essa se√ß√£o descreve as propriedades que voc√™ pode usar em detalhes. N√≥s nos referimos como ‚Äúpacote‚Äù mas o mesmo se aplica √† aplica√ß√µes locais que voc√™ n√£o utiliza como pacotes.

	A maioria dessas propriedades s√£o usadas apenas no https://www.npmjs.com/, outras por scripts que interagem com seu c√≥digo, como o npm ou outros.

	name

	Define o nome do pacote.

	Exemplo:

	"name": "test-project"

	O nome deve ter menos de 214 caracteres, n√£o pode ter espa√ßos, apenas letras min√∫sculas, h√≠fens (-) ou underlines (_).

	Isso ocorre porque quando um pacote √© publicado no npm, ele ganha sua pr√≥pria URL baseada nessa propriedade.

	Se voc√™ publicou esse pacote no GitHub, √© uma boa definir essa propriedade com o nome do reposit√≥rio no GitHub.

	author

	Lista o nome do autor do pacote

	Exemplo:

	{

	 "author": "Joe <joe@whatever.com> (https://whatever.com)"

	}

	Tamb√©m pode ser usado com esse formato:

	{

	 "author": {

	 "name": "Joe",

	 "email": "joe@whatever.com",

	 "url": "https://whatever.com"

	 }

	}

	contributors

	Assim como o autor, o projeto pode ter muitos contribuidores. Essa propriedade √© um array que os lista.

	Exemplo:

	{

	 "contributors": ["Joe <joe@whatever.com> (https://whatever.com)"]

	}

	Tamb√©m pode ser usado com esse formato:

	{

	 "contributors": [

	 {

	 "name": "Joe",

	 "email": "joe@whatever.com",

	 "url": "https://whatever.com"

	 }

	 ]

	}

	bugs

	Link para o rastreador de issues do pacote, geralmente uma p√°gina de issues do GitHub

	Exemplo:

	{

	 "bugs": "https://github.com/whatever/package/issues"

	}

	homepage

	Define a p√°gina inicial do site do pacote

	Exemplo:

	{

	 "homepage": "https://whatever.com/package"

	}

	version

	Indica a vers√£o atual do pacote.

	Exemplo:

	"version": "1.0.0"

	Essa propriedade segue o padr√£o de nota√ß√£o de versionamento sem√¢ntico chamado semver, o que significa que √© sempre expresso com 3 n√∫meros: x.x.x.

	O primeiro n√∫mero √© sempre a vers√£o major, o segundo a vers√£o minor e o terceiro a vers√£o patch.

	H√° um significado nesses n√∫meros: uma vers√£o que s√≥ corrige bugs √© uma vers√£o patch, uma vers√£o que introduz mudan√ßas compat√≠veis com vers√µes anteriores √© uma vers√£o minor, uma vers√£o major pode conter quebra de comportamentos com vers√µes antigas.

	license

	Indica a licen√ßa do pacote.

	Exemplo:

	"license": "MIT"

	keywords

	Esse propriedade cont√™m um array de palavras chave que s√£o associadas a o qu√™ esse projeto faz.

	Exemplo:

	"keywords": [

	 "email",

	 "machine learning",

	 "ai"

	]

	Isso ajuda pessoas a encontrarem seu pacote quando estiverem navegando por pacotes semelhantes, ou quando estiverem navegando no site https://www.npmjs.com/.

	description

	Essa propriedade cont√™m uma breve descri√ß√£o do pacote

	Exemplo:

	"description": "Um pacote para trabalhar com strings"

	Isso √© √∫til especialmente se voc√™ decide publicar seu pacote no npm, assim as pessoas podem encontrar sobre o qu√™ se trata aquele pacote.

	repository

	Essa propriedade especifica onde o reposit√≥rio desse pacote est√° localizado.

	Exemplo:

	"repository": "github:whatever/testing",

	Note o prefixo github. Tamb√©m h√° outros servi√ßos populares:

	"repository": "gitlab:whatever/testing",

	"repository": "bitbucket:whatever/testing",

	Voc√™ pode explicitar o sistema de controle de versionamento:

	"repository": {

	 "type": "git",

	 "url": "https://github.com/whatever/testing.git"

	}

	Voc√™ pode usar diferentes tipos de controle de versionamento:

	"repository": {

	 "type": "svn",

	 "url": "..."

	}

	main

	Define o ponto de entrada do pacote.

	Quando voc√™ importa esse pacote em uma aplica√ß√£o, √© onde a aplica√ß√£o vai procurar pelo module exports.

	Exemplo:

	"main": "src/main.js"

	private

	Se definido como true, previne do pacote ser publicado acidentalmente no npm

	Exemplo:

	"private": true

	scripts

	Define um conjunto de scripts node que voc√™ pode executar

	Exemplo:

	"scripts": {

	 "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",

	 "start": "npm run dev",

	 "unit": "jest --config test/unit/jest.conf.js --coverage",

	 "test": "npm run unit",

	 "lint": "eslint --ext .js,.vue src test/unit",

	 "build": "node build/build.js"

	}

	Esses scripts s√£o aplica√ß√µes de linha de comando. Voc√™ pode rod√°-los usando npm run XXXX ou yarn XXXX, sendo XXXX o nome do comando. Exemplo: npm run dev.

	Voc√™ pode usar o nome que quiser para o comando, e os scripts podem fazer qualquer coisa.

	dependencies

	Define uma lista de pacotes npm instalados como depend√™ncias.

	Quando voc√™ instala um pacote usando npm ou yarn:

	npm install <PACKAGENAME>

	yarn add <PACKAGENAME>

	esse pacote √© inserido automaticamente nessa lista.

	Exemplo:

	"dependencies": {

	 "vue": "^2.5.2"

	}

	devDependencies

	Define uma lista de pacotes npm instalados como depend√™ncias de desenvolvimento.

	Eles se diferem dos pacotes no dependencies porque eles s√£o instalados apenas em ambiente de desenvolvimento, n√£o s√£o necess√°rios para rodar o c√≥digo em produ√ß√£o.

	Quando voc√™ instala um pacote usando npm ou yarn:

	npm install --save-dev <PACKAGENAME>

	yarn add --dev <PACKAGENAME>

	esse pacote √© inserido automaticamente nessa lista.

	Exemplo:

	"devDependencies": {

	 "autoprefixer": "^7.1.2",

	 "babel-core": "^6.22.1"

	}

	engines

	Define em quais vers√µes do Node.js e outros comandos esse pacote opera

	Exemplo:

	"engines": {

	 "node": ">= 6.0.0",

	 "npm": ">= 3.0.0",

	 "yarn": "^0.13.0"

	}

	browserslist

	√â usado para definir quais browsers (e suas vers√µes) voc√™ deseja dar suporte. √â refenciado pelo Babel, Autoprefixer, e outras ferramentas, apenas para adicionar polyfills e fallbacks necess√°rias para o browser em quest√£o.

	Exemplo:

	"browserslist": [

	 "> 1%",

	 "last 2 versions",

	 "not ie <= 8"

	]

	Essa configura√ß√£o implica que voc√™ quer dar suporte paras as 2 √∫ltimas vers√µes major de todos os browsers com pelo menos 1% de uso (das estat√≠sticas do CanIUse.com), exceto IE8 ou anterior.

	(veja mais sobre)

	Propriedades espec√≠ficas de comandos

	O arquivo package.json tamb√©m pode conter configura√ß√µes espec√≠ficas de comandos, como por exemplo Babel, ESLint, e mais.

	Cada um tem propriedades espec√≠ficas, como eslintConfig, babel e outras. Voc√™ pode encontrar como utiliz√°-las em suas respectivas documenta√ß√µes.

	Vers√µes dos pacotes

	Voc√™ viu nos exemplos acima n√∫meros como esse: ~3.0.0 ou ^0.13.0. O que eles significam, e quais outros especificadores de vers√£o voc√™ pode usar?

	O s√≠mbolo especifica quais atualiza√ß√µes seu pacote aceita, para aquela depend√™ncia.

	Dado que ao usar semver (versionamento sem√¢ntico) todas vers√µes t√™m 3 d√≠gitos, o primeiro sendo a vers√£o major, o segundo a vers√£o minor e o terceiro a vers√£o patch, voc√™ tem essas regras.

	Voc√™ pode combinar a maioria das vers√µes em intervalos, como esse: 1.0.0 || >=1.1.0 <1.2.0, para usar ou 1.0.0 ou uma vers√£o maior ou igual que 1.1.0, mas menor que 1.2.0.

	O arquivo package-lock.json

	Na vers√£o 5, o npm introduziu o arquivo package-lock.json.

	O que √© isso? Voc√™ provavelmente conhece sobre o arquivo package.json, que √© muito mais comum e est√° por a√≠ a mais tempo.

	O objeto do arquivo √© manter rastreada a vers√£o exata de cada pacote que est√° instalado, assim o produto √© 100% reproduz√≠vel mesmo que pacotes sejam atualizados pelos seus mantenedores.

	Isso resolve um problema muito espec√≠fico que o package.json deixou para tr√°s. No package.json voc√™ pode definir para quais vers√µes voc√™ quer atualizar (patch ou minor), usando a nota√ß√£o semver, por exemplo:

	 	se voc√™ especifica ~0.13.0, voc√™ quer atualizar apenas para vers√µes patch: 0.13.1 est√° ok, mas 0.14.0 n√£o est√°.

	se voc√™ especifica ^0.13.0, voc√™ quer atualizar tanto para vers√µes patch quanto minor: 0.13.1, 0.14.0 e assim por diante.

	se voc√™ especifica 0.13.0, essa √© a vers√£o exata que ser√° utilizada, sempre



	Voc√™ n√£o commita a pasta node_modules no seu Git, que geralmente √© gigantesca, e quando voc√™ tenta replicar o projeto em outra m√°quina utilizando o comando npm install, se voc√™ especificou com a sintaxe ~ e uma vers√£o patch do pacote foi lan√ßada, ela que ser√° instalada. O mesmo para ^ e vers√µes inferiores.

	Se voc√™ especifica vers√µes exatas, como a 0.13.0 do exemplo, voc√™ n√£o ser√° afetado por esse problema.

	Pode ser com voc√™, ou com outra pessoa do outro lado do mundo tentando inicializar o projeto rodando npm install.

	Ent√£o seu projeto original e o novo projeto rec√©m inicializado s√£o na verdade diferentes. Mesmo que uma vers√£o patch ou minor n√£o introduza mudan√ßas que quebrem c√≥digos antigos, n√≥s todos sabemos que bugs podem (e v√£o) surgir.

	O package-lock.json grava na pedra a exata vers√£o instalada de cada pacote, e o npm vai utilizar essas exatas vers√µes quando rodar npm install.

	Esse conceito n√£o √© novo, e gerenciadores de pacotes de outras linguages (como o Composer no PHP) utilizam desse sistema por anos.

	O arquivo package-lock.json precisa ser commitado no seu reposit√≥rio Git, assim ele pode ser encontrado por outras pessoas, se o projeto √© p√∫blico ou voc√™ tem colaboradores, ou se voc√™ utiliza o GIT como fonte para deploys.

	As vers√µes das depend√™ncias v√£o ser atualizadas no arquivo package-lock.json quando voc√™ rodar npm update.

	Um exemplo

	Essa √© uma estrutura de exemplo de um arquivo package-lock.json que √© obtida quando rodamos npm install cowsay em uma pasta vazia:

	{

	 "requires": true,

	 "lockfileVersion": 1,

	 "dependencies": {

	 "ansi-regex": {

	 "version": "3.0.0",

	 "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.

	0.0.tgz",

	 "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="

	 },

	 "cowsay": {

	 "version": "1.3.1",

	 "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"

	,

	 "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM

	Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",

	 "requires": {

	 "get-stdin": "^5.0.1",

	 "optimist": "~0.6.1",

	 "string-width": "~2.1.1",

	 "strip-eof": "^1.0.0"

	 }

	 },

	 "get-stdin": {

	 "version": "5.0.1",

	 "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.

	1.tgz",

	 "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="

	 },

	 "is-fullwidth-code-point": {

	 "version": "2.0.0",

	 "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/

	is-fullwidth-code-point-2.0.0.tgz",

	 "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="

	 },

	 "minimist": {

	 "version": "0.0.10",

	 "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10

	.tgz",

	 "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="

	 },

	 "optimist": {

	 "version": "0.6.1",

	 "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",

	 "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",



	 "requires": {

	 "minimist": "~0.0.1",

	 "wordwrap": "~0.0.2"

	 }

	 },

	 "string-width": {

	 "version": "2.1.1",

	 "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",

	 "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",

	 "requires": {

	 "is-fullwidth-code-point": "^2.0.0",

	 "strip-ansi": "^4.0.0"

	 }

	 },

	 "strip-ansi": {

	 "version": "4.0.0",

	 "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",

	 "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",

	 "requires": {

	 "ansi-regex": "^3.0.0"

	 }

	 },

	 "strip-eof": {

	 "version": "1.0.0",

	 "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",

	 "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="

	 },

	 "wordwrap": {

	 "version": "0.0.3",

	 "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",

	 "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="

	 }

	 }

	}

	N√≥s instalamos o cowsay, que depende de:

	 	get-stdin

	optimist

	string-width

	strip-eof



	Por sua vez, esses pacotes dependem de outros pacotes, como podemos ver nos requires de alguns deles:

	 	ansi-regex

	is-fullwidth-code-point

	minimist

	wordwrap

	strip-eof



	Eles s√£o adicionados ao arquivo em ordem alfab√©tica, e cada um t√™m um campo version, um resolver, que aponta para a localiza√ß√£o do pacote, e um integrity, que √© uma string para valida√ß√£o do pacote.

	Veja as vers√µes instaladas de um pacote NPM

	Para ver a √∫ltima vers√£o de todos os pacotes npm instalados, incluindo suas depend√™ncias:

	npm list

	Por exemplo:

	‚ùØ npm list

	/Users/joe/dev/node/cowsay

	‚îî‚îÄ‚î¨ cowsay@1.3.1

	 ‚îú‚îÄ‚îÄ get-stdin@5.0.1

	 ‚îú‚îÄ‚î¨ optimist@0.6.1

	 ‚îÇ ‚îú‚îÄ‚îÄ minimist@0.0.10

	 ‚îÇ ‚îî‚îÄ‚îÄ wordwrap@0.0.3

	 ‚îú‚îÄ‚î¨ string-width@2.1.1

	 ‚îÇ ‚îú‚îÄ‚îÄ is-fullwidth-code-point@2.0.0

	 ‚îÇ ‚îî‚îÄ‚î¨ strip-ansi@4.0.0

	 ‚îÇ ‚îî‚îÄ‚îÄ ansi-regex@3.0.0

	 ‚îî‚îÄ‚îÄ strip-eof@1.0.0

	Voc√™ tamb√©m pode abrir o arquivo package-lock.json, mas voc√™ ter√° que ler muita informa√ß√£o desnecess√°ria.

	npm list -g tem o mesmo funcionamento, por√©m para pacotes instalados globalmente.

	Para obter obter apenas os pacotes top-level (basicamente aqueles que voc√™ pediu para o npm instalar e est√£o listados no package.json), execute npm list --depth=0:

	‚ùØ npm list --depth=0

	/Users/joe/dev/node/cowsay

	‚îî‚îÄ‚îÄ cowsay@1.3.1

	Voc√™ pode obter a vers√£o de um pacote em espec√≠fico fornecendo o nome dele:

	‚ùØ npm list cowsay

	/Users/joe/dev/node/cowsay

	‚îî‚îÄ‚îÄ cowsay@1.3.1

	Isso tamb√©m funciona para depend√™ncias dos pacotes instalados:

	‚ùØ npm list minimist

	/Users/joe/dev/node/cowsay

	‚îî‚îÄ‚î¨ cowsay@1.3.1

	 ‚îî‚îÄ‚î¨ optimist@0.6.1

	 ‚îî‚îÄ‚îÄ minimist@0.0.10

	Se voc√™ quer ver qual √© a √∫ltima vers√£o dispon√≠vel de um pacote no reposit√≥rio npm, execute npm view [package_name] version:

	‚ùØ npm view cowsay version



	1.3.1

	Instale uma vers√£o mais antiga de um pacote NPM

	Voc√™ pode instalar uma vers√£o antiga de um pacote npm usando a sintaxe @:

	npm install <package>@<version>

	Exemplo:

	npm install cowsay

	instala a vers√£o 1.3.1 (no momento de escrita).

	Instale a vers√£o 1.2.0 assim:

	npm install cowsay@1.2.0

	O mesmo pode ser feito com pacotes globais:

	npm install -g webpack@4.16.4

	Voc√™ tamb√©m pode estar interessado em listar todas as vers√µes anteriores de um pacote. Voc√™ pode fazer isso executando npm view <package> versions:

	‚ùØ npm view cowsay versions



	[ '1.0.0',

	 '1.0.1',

	 '1.0.2',

	 '1.0.3',

	 '1.1.0',

	 '1.1.1',

	 '1.1.2',

	 '1.1.3',

	 '1.1.4',

	 '1.1.5',

	 '1.1.6',

	 '1.1.7',

	 '1.1.8',

	 '1.1.9',

	 '1.2.0',

	 '1.2.1',

	 '1.3.0',

	 '1.3.1' ]

	Atualize todas as vers√µes do Node.js para a √∫ltima vers√£o.

	Quando voc√™ instala um pacote utilizando npm install <packagename>, a √∫ltima vers√£o dispon√≠vel do pacote √© baixada e colocada na pasta node_modules, e uma entrada correspondente √© adicionada nos arquivos package.json e package-lock.json presentes na pasta atual.

	o npm calcula as depend√™ncias e tamb√©m instala a √∫ltima vers√£o delas.

	Digamos que voc√™ instale o cowsay, uma ferramenta de linha de comando bem legal que te permite fazer uma vaca falar coisas.

	Quando voc√™ roda npm install cowsay, essa entrada √© adicionada no arquivo package.json:

	{

	 "dependencies": {

	 "cowsay": "^1.3.1"

	 }

	}

	e esse √© um trecho do package-lock.json, onde removemos as subdepend√™ncias para facilitar a leitura:

	{

	 "requires": true,

	 "lockfileVersion": 1,

	 "dependencies": {

	 "cowsay": {

	 "version": "1.3.1",

	 "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz",

	 "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkMAjufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",

	 "requires": {

	 "get-stdin": "^5.0.1",

	 "optimist": "~0.6.1",

	 "string-width": "~2.1.1",

	 "strip-eof": "^1.0.0"

	 }

	 }

	 }

	}

	Agora esses 2 arquivos nos dizem que instalamos a vers√£o 1.3.1 do cowsay, e nossa regra para atualiza√ß√µes √© ^1.3.1, o que o npm pode atualizar para vers√µes patch e minor: 1.3.2, 1.4.0 e assim por diante.

	Se h√° uma nova vers√£o minor ou patch e n√≥s digitamos npm update, a vers√£o instalada √© atualizada, e o arquivo package-lock.json rapidamente se atualiza com a nova vers√£o.

	o package.json permanece sem altera√ß√µes.

	Para descobrir novas atualiza√ß√µes dos pacotes, rode npm outdated.

	Aqui est√° uma lista de alguns pacotes desatualizados em um reposit√≥rio que n√£o recebe atualiza√ß√µes h√° um bom tempo:



	Algumas dessas atualiza√ß√µes s√£o para vers√µes major. Executando npm update elas n√£o ser√£o atualizadas. Vers√µes major nunca s√£o atualizadas desse jeito porque elas (por defini√ß√£o) introduzem mudan√ßas sujeitas a quebras em vers√µes antigas, e o npm quer nos poupar desse problema.

	Para atualizar para uma vers√£o major desses pacotes, instale o pacote npm-check-updates globalmente:

	npm install -g npm-check-updates

	e ent√£o rode:

	ncu -u

	isso ir√° atualizar as vers√µes no package.json, tanto dependencies quanto devDependencies, assim o npm poder√° instalar as vers√µes major.

	Agora voc√™ est√° pronto para executar as atualiza√ß√µes:

	npm update

	Se voc√™ s√≥ baixou o projeto sem as depend√™ncias do node_modules e quer instalar as novas vers√µes, basta rodar

	npm install

	Usando Semantic Versioning no NPM

	Se h√° uma coisa incr√≠vel nos pacotes Node.js, √© que todos eles permitem utilizar Versionamento Sem√¢ntico em suas numera√ß√µes de vers√£o.

	O Versionamento Sem√¢ntico √© um conceito simples: todas vers√µes t√™m 3 digitos: x.y.z.

	 	o primeiro digito √© a vers√£o major

	o segundo digito √© a vers√£o minor

	o terceiro digito √© a vers√£o patch



	Quando voc√™ cria uma nova vers√£o, voc√™ n√£o aumenta um n√∫mero como bem entender, existem algumas regras:

	 	voc√™ aumenta a vers√£o major quando voc√™ cria mudan√ßas de API incompat√≠veis

	voc√™ aumenta a vers√£o minor quando voc√™ adiciona uma funcionalidade compat√≠vel com vers√µes anteriores

	voc√™ aumenta a vers√£o patch quando voc√™ arruma bugs sem quebrar vers√µes anteriores



	Essa conven√ß√£o √© adotada em todas linguagens de programa√ß√£o, e √© muito importante que todo pacote npm a siga, pois o sistema como um todo depende disso.

	Por que isso √© t√£o importante?

	Porque o npm define algumas regras que podemos usar no package.json para escolher quais vers√µes podem ser atualizadas ao rodar npm update.

	As regras utilizam esses s√≠mbolos:

	 	^

	~

	>

	>=

	<

	<=

	=

	-

	||



	Vamos ver essas regras em detalhes:

	 	^: S√≥ vai fazer atualiza√ß√µes que n√£o alterem o n√∫mero mais a esquerda diferente de zero. Se voc√™ definir ^0.13.0, ao rodar npm update, ele pode atualizar para 0.13.1, 0.13.2, e assim por diante, mas n√£o para 0.14.0 ou posteriores. Se voc√™ definir ^1.13.0, ao rodar npm update, ele pode atualizar para 1.13.1, 1.14.0 e assim por diante, mas n√£o para 2.0.0 ou posterior.

	~: se voc√™ definir ~0.13.0, ao rodar npm update ele pode atualizar para vers√µes patch: 0.13.1 est√° ok, mas 0.14.0 n√£o est√°.

	>: aceita qualquer vers√£o maior que a especificada

	>=: aceita qualquer vers√£o maior ou igual a especificada

	<=: aceita qualquer vers√£o menor ou igual a especificada

	<: aceita qualquer vers√£o menor que a especificada

	=: aceita aquela exata vers√£o

	-: aceita qualquer vers√£o dentro de um intervalo. Exemplo: 2.1.0 - 2.6.2

	||: combina restri√ß√µes. Exemplo: < 2.1 || > 2.6



	Voc√™ pode combinar algumas dessas nota√ß√µes, por exemplo, utilize 1.0.0 || >=1.1.0 <1.2.0 para usar 1.0.0 ou uma vers√£o maior ou igual a 1.1.0, por√©m menor que 1.2.0.

	Tamb√©m h√° outras regras:

	 	sem s√≠mbolo: aceita apenas a vers√£o especificada (1.2.1)

	latest: usa a vers√£o mais recente dispon√≠vel



	Desinstalando pacotes NPM

	Para desinstalar um pacote que voc√™ tenha instalado previamente de forma local (usando npm install <package-name> na pasta node_modules), execute

	npm uninstall <package-name>

	a partir da pasta raiz do projeto (a pasta que cont√™m a pasta node_modules).

	Usando a flag -S, ou --save, essa opera√ß√£o tamb√©m ir√° remover a refer√™ncia no arquivo package.json.

	Se o pacote era uma depend√™ncia de desenvolvimento, listada no devDependencies do arquivo package.json, voc√™ deve utilizar a flag -D / --save-devpara remov√™-la do arquivo.

	npm uninstall -S <package-name>

	npm uninstall -D <package-name>

	Se o pacote est√° instalado globalmente, voc√™ precisa adicionar a flag -g / --global:

	npm uninstall -g <package-name>

	por exemplo:

	npm uninstall -g webpack

	e voc√™ pode rodar esse comando em qualquer lugar do seu sistema pois a pasta que voc√™ est√° n√£o importa. and you can run this command from anywhere you want on your system because the folder where you currently are does not matter.

	NPM: pacotes globais ou locais

	A principal diferen√ßa entre pacotes locais e globais √©:

	 	pacotes locais s√£o instalados no diret√≥rio em que voc√™ executa npm install <package-name>, e eles s√£o inseridos na pasta node_modules desse diret√≥rio.

	pacotes globais s√£o todos colocados em √∫nico lugar do seu sistema (dependendo da sua configura√ß√£o), independentemente de onde voc√™ execute npm install -g <package-name>



	No seu c√≥digo voc√™ s√≥ pode importar pacotes locais:

	require('package-name')

	ent√£o quando instalar um ou outro?

	No geral, todos os pacotes devem ser instalados localmente.

	Isso garante que voc√™ possa ter d√∫zias de aplica√ß√µes no seu computador, todas rodando com uma vers√£o diferente de cada pacote se necess√°rio.

	Atualizar um pacote global far√° com que todos seus projetos usem a nova vers√£o, e como voc√™ pode imaginar isso pode causar pesadelos em termos de manuten√ß√£o, pois alguns pacotes podem quebrar.

	Todos projetos tem sua pr√≥pria vers√£o local de um pacote, mesmo que isso possa parecer um desperd√≠cio de recursos, √© algo pequeno comparado as poss√≠veis consequ√™ncias.

	Um pacote deve ser instalado globalmente quando ele fornece um comando execut√°vel que possa ser rodado pelo terminal (CLI), e √© reutilizado entre projetos.

	Voc√™ tamb√©m pode instalar comandos execut√°veis localmente e rod√°-los usando o npx, por√©m alguns pacotes funcionam melhor instalados de forma global.

	Alguns otimos exemplos de pacotes globais populares que voc√™ pode conhecer:

	 	npm

	create-react-app

	vue-cli

	grunt-cli

	mocha

	react-native-cli

	gatsby-cli

	forever

	nodemon



	Voc√™ provavelmente j√° tem alguns deles instalados globalmente no seu sistema. Voc√™ pode conferir executando

	npm list -g --depth 0

	no seu terminal.

	npm: diferen√ßa entre dependencies e devDependencies

	Quando voc√™ instala um pacote usando npm install <package-name>, ele est√° sendo instalado como uma depend√™ncia.

	O pacote √© listado automaticamente no arquivo package.json, na lista de dependencies (a partir do npm 5: antes voc√™ tinha que especificar manualmente com --save).

	Quandi voc√™ adiciona a flag -D, ou --save-dev, voc√™ est√° instalado como uma depend√™ncia de desenvolvimento, que √© adicionada na lista de devDependencies.

	Depend√™ncias de desenvolvimento s√£o entendidas como pacotes apenas para desenvolver, n√£o s√£o necess√°rias em produ√ß√£o. Por exemplo pacotes de teste, webpack ou Babel.

	Quando voc√™ vai para produ√ß√£o, se digitar npm install e a pasta conter um arquivo package.json, elas s√£o instaladas, pois o npm assume que √© um deploy de desenvolvimento.

	Voc√™ precisa passar a flag --production (npm install --production) para evitar instalar essas depend√™ncias de desenvolvimento.

	Conhecendo o NPX

	npx √© um comando poderoso que est√° dispon√≠vel no npm a partir da vers√£o 5.2, lan√ßada em Julho de 2017.

	Se voc√™ n√£o quer instalar o npm, voc√™ pode instalar o npx como um pacote standalone

	O npx permite rodar seu c√≥digo feito com Node.js e publicado nos registros do npm.

	Rode comandos locais facilmente

	Desenvolvedores Node.js costumam publicar a maioria dos comandos execut√°veis como pacotes globais, pois assim √© garantido que eles estejam salvos no path e executados imediatamente.

	Isso √© bem chato poque voc√™ n√£o pode instalar vers√µes diferentes do mesmo comando.

	Ao rodar npx nomedocomando a refer√™ncia correta do comando dentro da pasta node_modules do projeto √© encontrada automaticamente, e sem a necessidade de saber o caminho exato, e sem a necessidade de ter o pacote instalado globalmente e no path do usu√°rio.

	Execu√ß√£o de comandos sem instala√ß√£o

	Outro excelente recurso do npx √© permitir rodar comandos sem t√™-los instalados.

	Isso √© extremamente √∫til, porque:

	 	voc√™ n√£o precisa instalar nada

	voc√™ pode rodar diferentes vers√µes do mesmo comando, usando a sintaxe @version



	Uma demonstra√ß√£o t√≠pica do uso do npx √© atrav√©s do comando cowsay. O cowsay vai imprimir uma vaca na tela dizendo o que voc√™ digitou no comando. Por exemplo:

	cowsay "Salve pra firma" vai resultar em

	 _________________

	< Salve pra firma >

	 -----------------

	 \ ^__^

	 \ (oo)\_______

	 (__)\ )\/\

	 ||----w |

	 || ||

	Isso s√≥ funciona se voc√™ tiver o comando cowsay previamente instalado pelo npm. Caso contr√°rio voc√™ receber√° um erro ao tentar rodar o comando.

	O npx permite que voc√™ rode o comando sem t√™-lo instalado localmente:

	npx cowsay "Salve pra firma"

	Outros cen√°rios de exemplo:

	 	rodar a CLI do vue para criar novas aplica√ß√µes: npx @vue/cli create my-vue-app

	criar uma aplica√ß√£o React usando create-react-app: npx create-react-app my-react-app



	Uma vez executado, o c√≥digo baixado ser√° apagado.

	Rodando um c√≥digo em uma vers√£o difente do Node.js

	Utilize o @ para especificar a vers√£o, e combine-o com uma vers√£o empacotada do node:

	npx node@10 -v #v10.18.1

	npx node@12 -v #v12.14.1

	Isso ajuda a evitar ferramentas como o nvm ou outros gerenciadores de vers√£o para Node.js.

	Rodando c√≥digos diretamente de uma URL

	O npx n√£o te limita aos pacotes publicados nos registros do npm.

	Voc√™ pode rodar c√≥digos de um gist no GitHub, por exemplo:

	npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32

	Mas √© claro que voc√™ precisa ter cuidado ao rodar c√≥digos que est√£o fora do seu controle, com grandes poderes vem grandes responsabilidades.

	O Event Loop do Node.js

	Introdu√ß√£o

	O Evnet Loop √© um dos aspectos do Node.js mais importantes de se entender.

	Por que ele √© t√£o importante? Porque ele explica como o Node.js pode ser ass√≠ncrono e ter I/O n√£o bloqueante, e tamb√©m explica o diferencial do Node.js, o qu√™ fez dele bem-sucedido.

	O c√≥digo JavaScript Node.js roda em uma √∫nica thread. H√° apenas uma coisa acontecendo por vez.

	Essa √© uma limita√ß√£o que na verdade √© bem √∫til, pois ela simplifica muito como voc√™ programa sem se preocupar com problemas de concorr√™ncia.

	Voc√™ s√≥ precisa prestar aten√ß√£o em como escrever seu c√≥digo e evitar qualquer coisa que possa bloquear a thread, como chamadas de rede s√≠ncronas ou loops infinitos.

	No geral, na maioria dos browsers existe um event loop para cada aba aberta, para tratar cada processo de forma isolada e evitar que uma p√°gina web com loops infinitos ou processamento pesado bloqueie o browser por completo.

	O ambiente de execu√ß√£o gerencia m√∫ltiplos event loops concorrentes, para fazer chamadas √† APIs por exemplo. Web Workers rodam em seus pr√≥prios event loops tamb√©m.

	Voc√™ precisa se preocupar principalmente com que seu c√≥digo rode um √∫nico event loop, e escrever o c√≥digo com isso em mente a fim de evitar bloquear a thread.

	Bloqueando o event loop

	Qualquer c√≥digo JavaScript que demore muito para retornar ao controle do event loop ir√° bloquear a execu√ß√£o de algum c√≥digo JavaScript na p√°gina, at√© mesmo bloquear a thread de UI, impossibilitando o usu√°rio de clicar, rolar, e etc.

	Quase todas primitivas de I/O no JavaScript s√£o n√£o bloqueantes. Requisi√ß√µes de rede, opera√ß√µes no filesystem, e etc. Ser bloqueante √© a exce√ß√£o, e esse √© o porqu√™ do JavaScript ser extremamente baseado em callbacks, e mais recentemente em promises e async/await.

	A call stack

	A call stack (pilha de chamadas) √© uma fila do tipo LIFO (Last In, First Out, que em portugu√™s significa √∫ltimo a entrar, primeiro a sair).

	O event loop checa continuamente a call stack para ver se h√° qualquer fun√ß√£o que precise rodar.

	Enquanto faz isso, ele adiciona na call stack qualquer chamada de fun√ß√£o que encontrar e executa cada uma em ordem.

	Sabe quando ocorre um erro e no debugger ou no console do browser aparece uma sequ√™ncia hier√°rquica de nomes de fun√ß√µes? Basicamente o browser procura os nomes das fun√ß√µes na call stack para te informar qual fun√ß√£o originou a chamada corrente:



	Uma explica√ß√£o simples sobre o event loop

	Dado esse exemplo:

	Quando esse c√≥digo roda, primeiro √© chamada foo(). Dentro de foo() n√≥s chamamos bar(), e ent√£o n√≥s chamamos baz().

	Nesse ponto a call stack se parece com isso:



	O event loop olha em toda itera√ß√£o se h√° algo na call stack, e o executa:



	at√© que a call stack esteja vazia.

	Enfileirando a execu√ß√£o de fun√ß√µes

	O exemplo acima parece normal, n√£o h√° nada de especial sobre ele: o JavaScript encontra coisas para executar, e as executa em ordem.

	Vamos ver como adiar uma fun√ß√£o at√© que a stack esteja vazia.

	O caso de uso do setTimeout(() => {}, 0) √© chamar uma fun√ß√£o, mas s√≥ execut√°-la assim que todas outras fun√ß√µes no c√≥digo tenham executado.

	Veja esse exemplo:

	Para nossa surpresa, esse c√≥digo imprime:

	foo

	baz

	bar

	Quando esse c√≥digo roda, primeiro foo() √© chamada. Dentro de foo() n√≥s chamamos setTimeout, passando bar como um argumento, e n√≥s instruimos a rod√°-la imediatamente, o mais r√°pido poss√≠vel, passando 0 como o tempo de contagem. E ent√£o n√≥s chamamos baz().

	Nesse ponto a call stack se parece com isso:



	Aqui temos a ordem de execu√ß√£o de todas as fun√ß√µes no nosso programa:



	Por que isso est√° acontecendo?

	A Message Queue

	Quando setTimeout() √© chamado, o Browser ou o Node.js come√ßa a contagem. Uma vez que ela encerre, nesse caso imediatamente pois definimos 0 como par√¢metro, a fun√ß√£o callback √© colocada na Message Queue (fila de mensagens).

	A Message Queue tamb√©m √© onde est√£o eventos iniciados pelo usu√°rio, como clicks ou pressionamento de teclas, ou respostas de requisi√ß√µes enfileiradas. antes do seu c√≥digo ter a oportunidade de reagir √† elas. Ou tamb√©m eventos do DOM, como onLoad.

	O loop d√° prioridade √† call stack, primeiro ele processa tudo que encontrar na call stack, e s√≥ depois que n√£o h√° nada l√°, ele come√ßa a pegar coisas na message queue.

	N√≥s n√£o temos que esperar por fun√ß√µes como setTimeout, fetch ou outras finalizarem, porque elas s√£o providas pelo browser, elas vivem em suas pr√≥prias threads. Por exemplo, se voc√™ definir o tempo do setTimeout como 2 segundos, voc√™ n√£o precisa esperar por 2 segundos - a espera ocorre em outro lugar.

	ES6 Job Queue

	O ECMAScript 2015 introduziu o conceito de Job Queue (fila de trabalhos), que √© usada por Promises (tamb√©m introduzidas no ES6/ES2015). √â uma maneira de executar o resultado de uma fun√ß√£o ass√≠ncrona o mais r√°pido poss√≠vel, inv√©s de colocar no fim da call stack.

	Promises que s√£o resolvidas antes da fun√ß√£o corrente encerrar ser√£o executadas logo ap√≥s a fun√ß√£o corrente.

	Eu acho legal a analogia de uma montanha russa em um parque de divers√µes: a message queue te coloca no final da fila, antes de todas outras pessoas, onde voc√™ ter√° que esperar pela sua vez, enquanto que a job queue √© um ticket corta filas que deixa voc√™ ir de novo ap√≥s a primeira ida.

	Exemplo:

	H√° uma grande diferen√ßa entre Promises (e Async/await, que √© feito com promises) e fun√ß√µes ass√≠ncronas antigas como setTimeout() ou outras APIs de plataforma.

	Entendendo o process.nextTick()

	Uma parte importante do event loop √© o process.nextTick().

	Toda vez que o event loop termina um ciclo, n√≥s chamamos isso de tick.

	Quando n√≥s passamos uma fun√ß√£o pro process.nextTick(), n√≥s instruimos a engine a invocar essa fun√ß√£o no fim da opera√ß√£o atual, antes que o pr√≥ximo tick do event loop tenha in√≠cio.

	process.nextTick(() => {

	 //fa√ßa algo

	})

	O event loop est√° ocupando processando o c√≥digo da fun√ß√£o atual.

	Quando a opera√ß√£o finaliza, a engine JS executa todas as fun√ß√µes passadas por chamadas do nextTick durante aquela opera√ß√£o.

	Esse √© o jeito que n√≥s podemos dizer √† engine JS para processar uma fun√ß√£o ass√≠ncronamente (depois da fun√ß√£o atual), mas o mais breve poss√≠vel, sem enfileirar.

	Chamando setTimeout(() => {}, 0) vai executar a fun√ß√£o no fim do pr√≥ximo tick, muito mais tarde do que quando usando nextTick(), que prioriza a chamada e a executa antes do pr√≥ximo tick.

	Use nextTick() quando voc√™ quer garantir que na pr√≥xima itera√ß√£o do event loop o c√≥digo j√° tenha sido executado.

	Entendendo setImmediate()

	Quando voc√™ quer executar um trecho de c√≥digo ass√≠ncronamente, mas o mais r√°pido poss√≠vel, uma op√ß√£o √© utilizar a fun√ß√£o setImmediate() provida pelo Node.js:

	setImmediate(() => {

	 //fa√ßa algo

	})

	Qualquer fun√ß√£o passada como argumento ao setImmediate() ser√° executada na pr√≥xima itera√ß√£o do event loop.

	Qual a diferen√ßa entre setImmediate(), setTimeout(() => {}, 0) (passando 0ms como delay), e process.nextTick()?

	A fun√ß√£o passada para o process.nextTick() ser√° executada na itera√ß√£o atual do event loop, depois que a opera√ß√£o corrente finalizar. Isso significa que ela sempre executa antes do setTimeout e do setImmediate.

	Uma callback setTimeout() com delay de 0ms √© muito similar ao setImmediate(). A ordem de execu√ß√£o vai depender de v√°rios fatores, mas ambas ir√£o rodar na pr√≥xima itera√ß√£o do event loop.

	Timers do JavaScript

	setTimeout()

	Quando estiver escrevendo c√≥digo JavaScript, voc√™ pode querer aplicar um delay na execu√ß√£o de uma fun√ß√£o.

	Esse √© o trabalho da fun√ß√£o setTimeout. Voc√™ especifica uma fun√ß√£o de callback para ser executada mais tarde, e um valor em milisegundos especificando o qu√£o mais tarde ela deve rodar:

	setTimeout(() => {

	 // roda ap√≥s 2 segundos

	}, 2000)



	setTimeout(() => {

	 // roda ap√≥s 50 milisegundos

	}, 50)

	Essa sintaxe define uma nova fun√ß√£o. Voc√™ pode chamar qualquer outra fun√ß√£o que quiser, ou passar o nome de uma fun√ß√£o existente, e definir os par√¢metros:

	const myFunction = (firstParam, secondParam) => {

	 // faz algo

	}



	// roda ap√≥s 2 segundos

	setTimeout(myFunction, 2000, firstParam, secondParam)

	setTimeout retorna o c√≥digo de identifica√ß√£o do timer. Geralmente esse c√≥digo n√£o √© usado, mas voc√™ pode guard√°-lo, e ‚Äúlimpar‚Äù o timer se voc√™ quiser desagendar a execu√ß√£o daquela fun√ß√£o:

	const id = setTimeout(() => {

	 // deve rodar daqui 2 segundos

	}, 2000)



	// mudei de ideia :v

	clearTimeout(id)

	Delay de zero

	Se voc√™ espeficiar o delay do timeout como 0, a fun√ß√£o de callback ser√° executada assim que poss√≠vel, mas s√≥ depois da execu√ß√£o das fun√ß√µes correntes:

	setTimeout(() => {

	 console.log('depois ')

	}, 0)



	console.log(' antes ')

	imprime antes depois.

	Isso √© especialmente √∫til para evitar bloqueio da CPU em tarefas intensas e deixar outras fun√ß√µes serem executadas enquanto s√£o feitos c√°lculos pesados, enfileirando fun√ß√µes no fluxo.

	Alguns browsers (IE e Edge) implementam um m√©todo chamado setImmediate() que tem a exata mesma funcionalidade, mas n√£o √© padronizado e indispon√≠vel em outros navegadores. Por√©m √© um m√©todo padr√£o no Node.js.

	setInterval()

	setInterval √© uma fun√ß√£o similar ao setTimeout, mas com uma diferen√ßa: em vez de rodar a fun√ß√£o de callback uma vez, ela ser√° rodada pra sempre, a cada intervalo de tempo especificado (em milisegundos):

	setInterval(() => {

	 // roda a cada 2 segundos

	}, 2000)

	A fun√ß√£o abaixo roda a cada 2 segundos at√© que voc√™ a diga pra parar, usando clearInterval, passando o identificador retornado por aquele setInterval:

	const id = setInterval(() => {

	 // roda a cada 2 segundos

	}, 2000)



	clearInterval(id)

	√â comum chamar o clearInterval dentro da fun√ß√£o de callback do setInterval, para auto-determinar se ele deve rodar de novo ou parar. Por exemplo, esse c√≥digo roda algo a n√£o ser que o valor de App.somethingIWait seja arrived:

	const interval = setInterval(() => {

	 if (App.somethingIWait === 'arrived') {

	 clearInterval(interval)

	 return

	 }

	 // caso contr√°rio, executa o conte√∫do restante

	}, 100)

	setTimeout recursivo

	O setInterval inicia uma fun√ß√£o a cada n milisegundos, sem levar em considera√ß√£o quando uma fun√ß√£o finalizou sua execu√ß√£o.

	Se uma fun√ß√£o gasta sempre o mesmo espa√ßo de tempo, show de bola:



	Talvez a fun√ß√£o gaste tempos diferentes de execu√ß√£o, dependendo das condi√ß√µes da internet por exemplo:



	E talvez uma longa execu√ß√£o sobreponha a pr√≥xima:



	Para evitar isso, voc√™ pode agendar um setTimout recursivo para ser chamado quando a fun√ß√£o de callback finaliza:

	const myFunction = () => {

	 // faz algo



	 setTimeout(myFunction, 1000)

	}



	setTimeout(myFunction, 1000)

	Pra chegar nesse cen√°rio:



	setTimeout e setInterval est√£o dispon√≠vels no Node.js, atrav√©s do m√≥dulo Timers.

	O Node.js tamb√©m disponibiliza o setImmediate(), que √© o equivalente de usar setTimeout(() => {}, 0), normalmente utilizado para trabalhar com o Event Loop do Node.js.

	Programa√ß√£o Assincrona e Callbacks

	Assincronicidade em Linguagens de Programa√ß√£o

	Computadores s√£o ass√≠ncronos por defini√ß√£o.

	Ass√≠ncrono significa que as coisas podem acontecer independemente do fluxo principal do programa.

	Nos computadores de uso dom√©stico atuais, cada programa roda por um intervalo de tempo espec√≠fico e, em seguida, interrompe sua execu√ß√£o para permitir que outro programa continue sua execu√ß√£o. Isso roda em um ciclo t√£o r√°pido que √© imposs√≠vel de notar. N√≥s pensamos que nossos computadores rodam diversos programass simultaneamente, mas isso √© uma ilus√£o (exceto em m√°quinas multiprocessadas).

	Programas usam internamente sinais de interrup√ß√£o (interrupts), que s√£o emitidos ao processador para ganharem a aten√ß√£o do sistema.

	N√£o irei muito a fundo no conceito, mas s√≥ tenha em mente que √© normal para programas serem ass√≠ncronos e pararem a execu√ß√£o at√© que precisem de aten√ß√£o, permitindo ao computador executar outras coisas nesse meio tempo. Quando um programa est√° esperando por uma resposta da rede, ele n√£o pode parar o processador at√© que a requisi√ß√£o finalize.

	Normalmente, linguagens de programa√ß√£o s√£o s√≠ncronas e algumas fornecem maneiras de gerenciar assincronicidade na pr√≥pria linguagem ou por meio de bibliotecas. C, Java, C#, PHP, Go, Ruby, Swift, e Python s√£o todas s√≠ncronas por padr√£o. Algumas delas gerenciam ass√≠ncronismo usando threads, gerando um novo processo.

	JavaScript

	JavaScript √© s√≠ncrono por padr√£o e roda em uma √∫nica thread. Isso significa que o c√≥digo n√£o pode criar novas threads e rodar em paralelo.

	Linhas de c√≥digo s√£o executadas em s√©ries, uma ap√≥s a outra, por exemplo:

	const a = 1

	const b = 2

	const c = a * b

	console.log(c)

	doSomething()

	Mas o JavaScript nasceu dentro dos browsers, sua fun√ß√£o principal, desde o come√ßo, era responder √†s intera√ß√µes do usu√°rio, como onClick, onMouseOver, onChange, onSubmit e etc. Como isso pode ser feito com um modelo program√°tico s√≠ncrono?

	A resposta era o ambiente. O browser d√° um jeito nisso fornecendo um conjunto de APIs que podem lidar com esses tipos de funcionalidades.

	Mais recentemente, o Node.js introduziu um ambiente de I/O n√£o bloqueante para estender esse conceito a acesso de arquivos, chamadas de rede e etc.

	Callbacks

	N√£o tem como voc√™ saber quando um usu√°rio vai clicar em um bot√£o. Ent√£o, voc√™ define uma fun√ß√£o para lidar com o evento de click. Essa fun√ß√£o ser√° chamada quando o evento for acionado:

	document.getElementById('button').addEventListener('click', () => {

	 // item clicado

	})

	Isso tamb√©m √© chamado de callback.

	Uma callback √© uma simples fun√ß√£o que √© passada como valor para outra fun√ß√£o, e s√≥ ser√° executada quando o evento ocorrer. N√≥s podemos fazer isso por que o JavaScript t√™m fun√ß√µes de ‚Äúprimeira classe‚Äù, que podem ser atribuidas √† vari√°veis e passadas para outras fun√ß√µes chamadas de higher-order functions (fun√ß√µes de ordem superior).

	√â comum envolver todo c√≥digo do cliente em um event listener do tipo load no objeto window, que roda s√≥ roda a fun√ß√£o callback quando a p√°gina est√° pronta:

	window.addEventListener('load', () => {

	 // window carregou

	 // fa√ßa o que quiser

	})

	Callbacks s√£o usadas em todo lugar, n√£o s√≥ em eventos do DOM.

	Um exemplo comum √© utilizando temporizadores:

	setTimeout(() => {

	 // roda ap√≥s 2 segundos

	}, 2000)

	Requisi√ß√µes XHR tamb√©m aceitam uma callback, nesse exemplo ao passar uma fun√ß√£o para uma propriedade que ser√° chamada quando um evento em particular ocorrer (nesse caso, o estado da requisi√ß√£o mudar):

	const xhr = new XMLHttpRequest()

	xhr.onreadystatechange = () => {

	 if (xhr.readyState === 4) {

	 xhr.status === 200 ? console.log(xhr.responseText) : console.error('error')

	 }

	}

	xhr.open('GET', 'https://yoursite.com')

	xhr.send()

	Tratando erros em callbacks

	Como voc√™ trata erros em callbacks? Uma estrat√©gia muito comum √© usar o que o Node.js adotou: o primeiro par√¢metro em qualquer fun√ß√£o callback √© o objeto de erro: error-first callbacks

	Se n√£o h√° erro, o objeto √© nulo (null). Se h√° um erro, ele cont√™m alguma descri√ß√£o do erro e outras informa√ß√µes.

	fs.readFile('/file.json', (err, data) => {

	 if (err !== null) {

	 // tratando erro

	 console.log(err)

	 return

	 }



	 // sem erros, processe o data

	 console.log(data)

	})

	O problema com callbacks

	Callbacks s√£o √≥timas para casos simples!

	Entretanto, toda callback adiciona um n√≠vel de aninhamento, e quando voc√™ t√™m muitas callbacks, o c√≥digo come√ßa a se complicar rapidamente:

	window.addEventListener('load', () => {

	 document.getElementById('button').addEventListener('click', () => {

	 setTimeout(() => {

	 items.forEach(item => {

	 // seu c√≥digo aqui

	 })

	 }, 2000)

	 })

	})

	Esse √© s√≥ um exemplo simples com 4 n√≠veis de aninhamento, mas eu j√° vi c√≥digos com muito mais n√≠veis e n√£o √© nem um pouco divertido.

	Como resolver isso?

	Alternativas √† callbacks

	A partir do ES6, o JavaScript introduziu v√°rias funcionalidades que nos ajudam a lidar com c√≥digo ass√≠ncrono sem o uso de callbacks: Promises (ES6) e Async/Await (ES2017).

	Promises no JavaScript

	Introdu√ß√£o a Promises

	Uma promise (promessa) √© comumente definida como um proxy para um valor que eventualmente ficar√° dispon√≠vel.

	Promises s√£o um jeito de lidar com c√≥digo ass√≠ncrono, sem ficar preso em ‚Äúinferno de callbacks‚Äù (callback hell).

	Promises s√£o parte da linguagem por anos (introduzidas e padronizadas no ES2015), e se tornaram mais integradas recentemente, com async e await no ES2017.

	Fun√ß√µes async usam promises por baixo dos panos, ent√£o entender como promises funcionam √© fundamental para entender como async e await funcionam.

	Como promises funcionam, resumidamente

	Uma vez que a promise tenha sido chamada, ela inicia em um estado pendente (pending). Isso significa que a fun√ß√£o que a chamou continua executando, enquanto a promise estiver pendente at√© que se resolva, retornando √† fun√ß√£o que a invocou os dados que foram requisitados.

	A promise criada vai eventualmente se encerrar em um estado resolvido (resolved), ou em um estado rejeitado (rejected), chamando as respectivas fun√ß√µes callback (then e catch) ao terminar.

	Quais APIs JS usam promises?

	Em adi√ß√£o ao seu c√≥digo e o de bibliotecas, promises s√£o usadas por padr√£o em APIs web modernas, como:

	 	Battery API

	Fetch API

	Service Workers



	√â improv√°vel que voc√™ mesmo n√£o esteja utilizando promises no JavaScript moderno, ent√£o vamos come√ßar a mergulhar nelas.





* * *



	Criando uma promise

	A Promise API exp√µe um contrutor Promise, por onde voc√™ inicializa usando new Promise():

	let done = true



	const isItDoneYet = new Promise((resolve, reject) => {

	 if (done) {

	 const workDone = 'Here is the thing I built'

	 resolve(workDone)

	 } else {

	 const why = 'Still working on something else'

	 reject(why)

	 }

	})

	Como voc√™ pode ver, a promise checa a constante global done, e se for true, a promise vai para o estado resolved (uma vez que a callback resolve tenha sido chamada); caso contr√°rio, a callback reject √© executada, colocando a promise em um estado rejected. (Se nenhuma dessas fun√ß√µes √© chamada, a promise permanece no estado pending).

	Usando resolve e reject, podemos nos comunicar com a fun√ß√£o invocadora dizendo qual estado a promise estava, e o que fazer com isso. No caso acima n√≥s s√≥ retornamos uma string, mas poderia ser um objeto, ou mesmo null. S√≥ de termos criado a promise no trecho acima, ela j√° come√ßou a executar. √â importante entender o que est√° acontecendo na se√ß√£o Consumindo uma promise logo abaixo.

	Um exemplo mais comum que voc√™ pode encontrar por a√≠ √© uma t√©cnica chamada Promisifying (promissificar). Essa t√©cnica √© um jeito de poder usar uma fun√ß√£o JavaScript cl√°ssica que recebe uma callback, e retornar uma promise:

	const fs = require('fs')



	const getFile = (fileName) => {

	 return new Promise((resolve, reject) => {

	 fs.readFile(fileName, (err, data) => {

	 if (err) {

	 reject (err) // chamar `reject` vai fazer com que a promise falhe com ou sem o erro passado como argumento

	 return // e n√£o queremos ir mais longe

	 }

	 resolve(data)

	 })

	 })

	}



	getFile('/etc/passwd')

	.then(data => console.log(data))

	.catch(err => console.error(err))

	Em vers√µes recentes do Node.js, voc√™ n√£o precisa fazer essa convers√£o manual para grande parte da API. H√° uma fun√ß√£o promisifying dispon√≠vel no m√≥dulo util que far√° isso por voc√™, dado que a fun√ß√£o que voc√™ esteja ‚Äúpromissificando‚Äù siga a assinatura correta.





* * *



	Consumindo uma promise

	Na √∫ltima se√ß√£o, n√≥s introduzimos como uma promise √© criada.

	Agora vamos ver como uma promise pode ser consumida ou usada.

	const isItDoneYet = new Promise(/* ... como acima ... */)

	//...



	const checkIfItsDone = () => {

	 isItDoneYet

	 .then(ok => {

	 console.log(ok)

	 })

	 .catch(err => {

	 console.error(err)

	 })

	}

	Rodar checkIfItsDone() vai especificar fun√ß√µes para executar quando a promise isItDoneYet resolver (na chamada then) ou rejeitar (na chamada catch).





* * *



	Encadeando promises

	Uma promise pode ser retornada para outra promise, criando uma cadeia de promises.

	Um √≥timo exemplo de encadeamento de promises √© a Fetch API, que podemos usar para obter um recurso e enfileirar uma cadeia de promises para executar quando o recurso for obtido.

	A Fetch API um mecanismo baseado em promise, e chamar fetch() √© equivalente a definir suas pr√≥prias promises usando new Promise().

	Exemplo de encadeamento de promises

	const status = response => {

	 if (response.status >= 200 && response.status < 300) {

	 return Promise.resolve(response)

	 }

	 return Promise.reject(new Error(response.statusText))

	}



	const json = response => response.json()



	fetch('/todos.json')

	 .then(status) // note que a fun√ß√£o `status` √© na verdade **chamada** aqui, e ela **retorna uma promise**

	 .then(json) // da mesma forma, a √∫nica diferen√ßa aqui √© que a fun√ß√£o `json` retorna uma promise que √© resolvida com `data`

	 .then(data => { // ... por isso que `data` aparece aqui como primeiro par√¢metro da fun√ß√£o an√¥nima

	 console.log('Request succeeded with JSON response', data)

	 })

	 .catch(error => {

	 console.log('Request failed', error)

	 })

	Nesse exemplo, n√≥s chamamos fetch() para obter uma lita de items TODO do arquivo todos.json localizado na raiz do dom√≠nio, e n√≥s criamos uma cadeia de promises.

	Rodanr fetch() retorna uma response (resposta), que cont√©m v√°rias propriedades, e dentre elas as que usamos no exemplo:

	 	status, um valor num√©rico representando o c√≥digo de status HTTP

	statusText, uma mensagem de status, que ser√° OK se a requisi√ß√£o for bem-sucedida.



	response tamb√©m tem um m√©todo json(), que retorna uma promise que vai resolver com o conte√∫do do body processado e transformado em JSON.

	Ent√£o dadas essas promises, isso √© o que acontece: a primeira promise na cadeia √© a fun√ß√£o que n√≥s definimos, chamada status(), que checa o status da response e se n√£o for uma resposta bem-sucedida (entre 200 e 299), a promise √© rejeitada.

	Essa opera√ß√£o far√° com que a cadeia de promises pule todas promises encadeadas e pule diretamente para o catch() no final, logando o texto Request failed e a mensagem de erro.

	Se em vez disso obter suceddo, √© chamada a fun√ß√£o json() que definimos. Desde que a promise anterior, quando bem-sucedida, tenha retornado o objeto response, n√≥s o obtemos como um input para a segunda promise.

	Nesse caso, n√≥s retornamos os dados processados em JSON, assim a terceira promise recebe o JSON diretamente:

	.then((data) => {

	 console.log('Request succeeded with JSON response', data)

	})

	e n√≥s simplesmente o logamos no console.





* * *



	Tratando erros

	No exemplo da se√ß√£o anterior, n√≥s tinhamos um catch que foi adicionado na cadeia de promises.

	Quando qualquer coisa na cadeia de promises falha e dispara um erro ou rejeita uma promise, o controle vai para o catch() mais pr√≥ximo na cadeia.

	new Promise((resolve, reject) => {

	 throw new Error('Error')

	}).catch(err => {

	 console.error(err)

	})



	// or



	new Promise((resolve, reject) => {

	 reject('Error')

	}).catch(err => {

	 console.error(err)

	})

	Cascateando erros

	Se dentro do catch() voc√™ lan√ßar um erro, voc√™ pode adicionar um segundo catch() para trat√°-lo, e assim por diante.

	new Promise((resolve, reject) => {

	 throw new Error('Error')

	})

	 .catch(err => {

	 throw new Error('Error')

	 })

	 .catch(err => {

	 console.error(err)

	 })





* * *



	Orquestrando promises

	Promise.all()

	Se voc√™ precisa sincronizar promises diferentes, Promise.all() te ajuda a definir uma lista de promises, e executa algo quando elas todas s√£o resolvidas.

	Examplo:

	const f1 = fetch('/something.json')

	const f2 = fetch('/something2.json')



	Promise.all([f1, f2])

	 .then(res => {

	 console.log('Array of results', res)

	 })

	 .catch(err => {

	 console.error(err)

	 })

	A sintaxe de atribui√ß√£o por desestrutura√ß√£o do ES2015 permite que voc√™ tamb√©m fa√ßa isso:

	Promise.all([f1, f2]).then(([res1, res2]) => {

	 console.log('Results', res1, res2)

	})

	√â claro que voc√™ n√£o est√° limitado a s√≥ usar o fetch, qualquer promise pode ser usada dessa forma.

	Promise.race()

	Promise.race() roda quando a primeira das promises que voc√™ passar for resolvida, e roda a callback anexada apenas uma vez, com o resultado da primeira promise resolvida.

	Exemplo:

	const first = new Promise((resolve, reject) => {

	 setTimeout(resolve, 500, 'first')

	})

	const second = new Promise((resolve, reject) => {

	 setTimeout(resolve, 100, 'second')

	})



	Promise.race([first, second]).then(result => {

	 console.log(result) // second

	})

	Erros comuns

	Uncaught TypeError: undefined is not a promise

	Se voc√™ obter um erro Uncaught TypeError: undefined is not a promise no console, certifique-se de usar new Promise() em vez de apenas Promise().

	UnhandledPromiseRejectionWarning

	Isso significa que a promise que voc√™ chamou foi rejeitada, mas n√£o tinha nenhum catch preparado para tratar o erro. Adicione um catch depois do then causador do erro para trat√°-lo propriamente.

	Programa√ß√£o assincrona moderna com Async Await no Javascript

	Introdu√ß√£o

	O JavaScript evoluiu de callbacks para promises (ES2015) em um curto per√≠odo de tempo, e desde o ES2017, JavaScript ass√≠ncrono est√° ainda mais simples com a sintaxe async/await.

	Fun√ß√µes async s√£o uma combina√ß√£o de promises e generators, e basicamente, elas s√£o uma abstra√ß√£o de alto n√≠vel das promises. Permita-me repetir: async/await √© feito com promises.

	Por que a sintaxe async/await foi criada?

	Ela reduz o amontoado de c√≥digo em torno das prommises e a limita√ß√£o de ‚Äún√£o quebre a corrente‚Äù das promises encadeadas.

	Quando as Promises foram introduzidas no ES2016, elas foram feitas para resolver um problema com c√≥digo ass√≠ncrono, e elas fizeram isso, mas ao longos dos 2 anos que separaram o ES2015 do ES2017, ficou claro que promises poderiam n√£o ser a solu√ß√£o definitiva.

	Promises foram introduzidas para resolver o famoso problema de callback hell, mas elas introduziram complexidade por si s√≥, e complexidade sint√°tica.

	Elas foram boas primitivas enquanto uma sintaxe melhor n√£o surgia, ent√£o, quando chegou a hora certa, obtivemos as fun√ß√µes async.

	Elas fazem o c√≥digo parecer s√≠ncrono, mas por baixo dos panos ele √© ass√≠ncrono e n√£o bloqueante.

	Como isso funciona

	Uma fun√ß√£o async retorna uma promise, como nesse exemplo:

	const doSomethingAsync = () => {

	 return new Promise(resolve => {

	 setTimeout(() => resolve('I did something'), 3000)

	 })

	}

	Quando voc√™ quer chamar essa fun√ß√£o voc√™ prexifa um await, e o c√≥digo corrente vai parar at√© que a promise seja resolvida ou rejeitada. Uma ressalva: a fun√ß√£o deve ser definida como async. Segue um exemplo:

	const doSomething = async () => {

	 console.log(await doSomethingAsync())

	}

	Um exemplo r√°pido

	Esse √© um exemplo bem simples de async/await sendo usado para rodar uma fun√ß√£o ass√≠ncronamente:

	‚ÄúPromissifique‚Äù tudo

	Prefixar o termo async em qualquer fun√ß√£o implica que a fun√ß√£o vai retornar uma promise.

	Mesmo que isso n√£o seja feito t√£o explicitamente, internamente far√° com que retorne uma promise.

	Por isso que esse c√≥digo √© v√°lido:

	const aFunction = async () => {

	 return 'test'

	}



	aFunction().then(alert) // Isso vai invocar um alert com o texto 'test'

	e o mesmo aqui:

	const aFunction = async () => {

	 return Promise.resolve('test')

	}



	aFunction().then(alert) // Isso vai invocar um alert com o texto 'test'

	O c√≥digo √© muito mais simples de ler

	Como voc√™ p√¥de ver no exemplo acima, nosso c√≥digo parece muito simples. Compare-o com os c√≥digos usando promises simples, encadeamento e fun√ß√µes callback.

	E esse √© um exemplo bem simples, os maiores benef√≠cios v√£o aparecer quando o c√≥digo for mais complexo.

	Por exemplo, aqui temos um c√≥digo de como obter um recurso JSON e ‚Äúparsear‚Äù, usando promises:

	const getFirstUserData = () => {

	 return fetch('/users.json') // pega a lista de users

	 .then(response => response.json()) // parse JSON

	 .then(users => users[0]) // pega o primeiro usu√°rio

	 .then(user => fetch(`/users/${user.name}`)) // pega os dados desse usu√°rio

	 .then(userResponse => userResponse.json()) // parse JSON

	}



	getFirstUserData()

	E aqui temos a mesma funcionalidade usando async/await:

	const getFirstUserData = async () => {

	 const response = await fetch('/users.json') // pega a lista de users

	 const users = await response.json() // parse JSON

	 const user = users[0] // pega o primeiro usu√°rio

	 const userResponse = await fetch(`/users/${user.name}`) // pega os dados desse usu√°rio

	 const userData = await userResponse.json() // parse JSON

	 return userData

	}



	getFirstUserData()

	M√∫ltiplas fun√ß√µes async em s√©rie

	Fun√ß√µes async podem ser encadeadas facilmente, e a sintaxe √© muito mais leg√≠vel do que usando promises simples:

	Mais f√°cil de debugar

	√â dif√≠cil debugar promises porque o debugger n√£o passa por cima de c√≥digo ass√≠ncrono.

	J√° Async/await facilita muito isso porque para o compilador √© como se fosse apenas c√≥digo s√≠ncrono.

	O Event emitter

	Se voc√™ j√° trabalhou com JavaScript no browser, j√° sabe o qu√£o grande √© a quantidade de a√ß√µes do usu√°rio que s√£o tratadas por eventos: clicks do mouse, teclas sendo pressionadas, movimentos do mouse, e muito mais.

	No lado do backend, o Node.js nos oferece a op√ß√£o de trabalhar com um sitema similar usando o m√≥dulo events.

	Esse m√≥dulo, em particular, fornece a classe EventEmitter, que n√≥s utilizaremos para lidar com nossos eventos.

	Voc√™ a inicializa usando

	const EventEmitter = require('events')

	const eventEmitter = new EventEmitter()

	Esse objeto exp√µe, entre muitos outros, os m√©todos on e emit.

	 	emit √© usado para acionar um evento

	on √© usado para adicionar uma fun√ß√£o callback que ser√° executada quando o evento for acionado



	Por exemplo, vamos criar um evento start, e para dar uma amostra gr√°tis, vamos reagir a ele logando no console:

	eventEmitter.on('start', () => {

	 console.log('started')

	})

	Quando rodamos

	eventEmitter.emit('start')

	a fun√ß√£o que lida com o evento √© acionada, e obtemos o log.

	Voc√™ pode passar argumentos √† fun√ß√£o passando-os como argumentos adicionais do emit():

	eventEmitter.on('start', number => {

	 console.log(`started ${number}`)

	})



	eventEmitter.emit('start', 23)

	M√∫ltipos argumentos:

	eventEmitter.on('start', (start, end) => {

	 console.log(`started from ${start} to ${end}`)

	})



	eventEmitter.emit('start', 1, 100)

	O objeto EventEmitter tamb√©m exp√µe diversos outros m√©todos que interagem com eventos, como

	 	once(): escuta o evento apenas uma vez

	removeListener() / off(): remove um escutador (listener) de um evento

	removeAllListeners(): remove todos escutadores (listeners) de um evento



	Voc√™ pode ler o detalhe de todos eles na p√°gina do m√≥dulo events em https://nodejs.org/api/events.html

	Construa um HTTP Server

	Aqui temos um simples web server HTTP de Hello World:

	Vamos analisar esse c√≥digo brevemente. N√≥s incluimos o m√≥dulo http.

	N√≥s usamos o m√≥dulo para criar um servidor HTTP.

	√â definido para o servidor escutar na porta especificada, 3000. Quando o servidor est√° pronto, a fun√ß√£o callback listen √© chamada.

	A fun√ß√£o callback que passamos √© a que ser√° executada em toda requisi√ß√£o. Sempre que uma nova requisi√ß√£o √© recebida, o evento request √© chamado, fornecendo dois objetos: request (inst√¢ncia de http.IncomingMessage) e response (inst√¢ncia de http.ServerResponse).

	request cont√©m os detalhes da requisi√ß√£o. Atrav√©s dele, n√≥s acessamos os cabe√ßalhos (headers) e os dados da requisi√ß√£o.

	response √© usado para popular os dados que vamos retornar ao cliente.

	No seguinte caso

	res.statusCode = 200

	n√≥s definimos a propriedade statusCode para 200, para indicar uma resposta bem sucedida.

	N√≥s tamb√©m definimos a header Content-Type:

	res.setHeader('Content-Type', 'text/plain')

	e fechamos a resposta, adicionando o conte√∫do como um argumento do end():

	res.end('Hello World\n')

	Fazendo requisi√ß√µes HTTP com o Node.js

	Realizando uma requisi√ß√£o do tipo GET

	const https = require('https')

	const options = {

	 hostname: 'whatever.com',

	 port: 443,

	 path: '/todos',

	 method: 'GET'

	}



	const req = https.request(options, res => {

	 console.log(`statusCode: ${res.statusCode}`)



	 res.on('data', d => {

	 process.stdout.write(d)

	 })

	})



	req.on('error', error => {

	 console.error(error)

	})



	req.end()

	Realizando uma requisi√ß√£o do tipo POST

	const https = require('https')



	const data = JSON.stringify({

	 todo: 'Buy the milk'

	})



	const options = {

	 hostname: 'whatever.com',

	 port: 443,

	 path: '/todos',

	 method: 'POST',

	 headers: {

	 'Content-Type': 'application/json',

	 'Content-Length': data.length

	 }

	}



	const req = https.request(options, res => {

	 console.log(`statusCode: ${res.statusCode}`)



	 res.on('data', d => {

	 process.stdout.write(d)

	 })

	})



	req.on('error', error => {

	 console.error(error)

	})



	req.write(data)

	req.end()

	Requisi√ß√µes do tipos PUT e DELETE

	Requisi√ß√µes PUT e DELETE usam o mesmo formato da requisi√ß√£o POST, mudando apenas o valor do options.method.

	Fa√ßa um HTTP POST request com Node.js

	Existem diversas maneiras de realizar uma requisi√ß√£o do tipo POST no Node.js, dependendo do n√≠vel de abstra√ß√£o que voc√™ quer utilizar.

	O jeito mais simples de fazer uma requisi√ß√£o HTTP usando Node.js √© usar a biblioteca Axios:

	const axios = require('axios')



	axios

	 .post('https://whatever.com/todos', {

	 todo: 'Buy the milk'

	 })

	 .then(res => {

	 console.log(`statusCode: ${res.statusCode}`)

	 console.log(res)

	 })

	 .catch(error => {

	 console.error(error)

	 })

	Utilizar o Axios requer o uso de uma biblioteca de terceiros.

	√â poss√≠vel fazer uma requisi√ß√£o POST usando apenas os m√≥dulos nativos do Node.js, por√©m √© mais verboso que as duas op√ß√µes anteriores:

	const https = require('https')



	const data = JSON.stringify({

	 todo: 'Buy the milk'

	})



	const options = {

	 hostname: 'whatever.com',

	 port: 443,

	 path: '/todos',

	 method: 'POST',

	 headers: {

	 'Content-Type': 'application/json',

	 'Content-Length': data.length

	 }

	}



	const req = https.request(options, res => {

	 console.log(`statusCode: ${res.statusCode}`)



	 res.on('data', d => {

	 process.stdout.write(d)

	 })

	})



	req.on('error', error => {

	 console.error(error)

	})



	req.write(data)

	req.end()

	Fa√ßa uma requisi√ß√£o GET de HTTP com body usando Node.js

	Aqui temos como voc√™ pode extrair dados que foram enviados como JSON no corpo da requisi√ß√£o:

	Se voc√™ est√° usando Express, √© bem simples: utilize o m√≥dulo body-parser.

	Por exemplo, para obter o corpo dessa requisi√ß√£o:

	const axios = require('axios')



	axios.post('https://whatever.com/todos', {

	 todo: 'Buy the milk'

	})

	Esse √© o c√≥digo do servidor que vai receber a requisi√ß√£o:

	const express = require('express')

	const app = express()



	app.use(

	 express.urlencoded({

	 extended: true

	 })

	)



	app.use(express.json())



	app.post('/todos', (req, res) => {

	 console.log(req.body.todo)

	})

	Se voc√™ n√£o est√° usando Express, e voc√™ quer fazer isso em Node.js raiz, ter√° um pouco mais de trabalho, √© claro, pois o Express abstrai muitas coisas pra voc√™.

	O ponto chave pra se entender √© que quando voc√™ inicializa um servidor HTTP usando http.createServer(), a callback √© chamada quando o servidor obt√™m todos os cabe√ßalhos HTTP, mas n√£o o body (corpo da requisi√ß√£o).

	O objeto request passado na conex√£o de callback √© uma stream.

	Ent√£o, n√≥s devemos escutar pelo conte√∫do do body a ser processado, e ele √© processado em chunks(peda√ßos).

	Primeiro n√≥s obtemos os dados escutando os eventos de data da stream, e quando eles finalizam, a stream emite o evento end:

	const server = http.createServer((req, res) => {

	 // n√≥s podemos acessar os cabe√ßalhos HTTP

	 req.on('data', chunk => {

	 console.log(`Data chunk available: ${chunk}`)

	 })

	 req.on('end', () => {

	 // fim dos eventos data

	 })

	})

	Ent√£o para acessar os dados, assumindo que esperamos receber uma string, n√≥s devemos coloc√°-los em um array:

	const server = http.createServer((req, res) => {

	 let data = '';

	 req.on('data', chunk => {

	 data += chunk;

	 })

	 req.on('end', () => {

	 JSON.parse(data).todo // 'Buy the milk'

	 })

	})

	Trabalhando com file descriptors node Node.js

	Antes que voc√™ seja capaz de interagir com um arquivo presente no seu filesystem, voc√™ deve obter um file descriptor (descritor de arquivo).

	Um file descriptor √© o que √© retornado ao abrir um arquivo utilizando o m√©todo open() do m√≥dulo fs:

	const fs = require('fs')



	fs.open('/Users/joe/test.txt', 'r', (err, fd) => {

	 // fd √© o nosso file descriptor

	})

	Note o r que usamos como segundo par√¢metro da chamada fs.open().

	Essa flag significa que n√≥s abrimos o arquivo para leitura.

	Outras flags que voc√™ normalmente utilizar√° s√£o:

	 	r+ abre o arquivo para leitura e escrita

	w+ abre o arquivo para leitura e escrita, posicionando a stream no in√≠cio do arquivo. O arquivo √© criado se n√£o existir.

	a abre o arquivo para escrita, posicionando a stream no fim do arquivo. O arquivo √© criado se n√£o existir.

	a+ abre o arquivo para leitura e escrita, posicionando a stream no fim do arquivo. O arquivo √© criado se n√£o existir.



	Voc√™ tamb√©m pode abrir o arquivo utilizando o m√©todo fs.openSync, que retorna o file descriptor, em vez de fornec√™-lo dentro de uma callback:

	const fs = require('fs')



	try {

	 const fd = fs.openSync('/Users/joe/test.txt', 'r')

	} catch (err) {

	 console.error(err)

	}

	Uma vez que voc√™ obtenha o file descriptor, independentemente do m√©todo escolhido, voc√™ pode fazer todas opera√ß√µes que o requerem, como chamar fs.open() e muitas outras opera√ß√µes que interagem com o filesystem.

	Node.js file stats

	Todo arquivo vem com um conjunto de detalhes que n√≥s podemos inspecionar usando Node.js.

	Em particular, usando o m√©todo stat() do m√≥dulo fs.

	Voc√™ o chama passando o caminho do arquivo, e uma vez que o Node.js obtenha os detalhes do arquivo ele chamar√° a fun√ß√£o callback que voc√™ passar, com 2 par√¢metros: uma mensagem de erro, e os detalhes do arquivo.

	const fs = require('fs')

	fs.stat('/Users/joe/test.txt', (err, stats) => {

	 if (err) {

	 console.error(err)

	 return

	 }

	 // n√≥s temos acesso aos detalhes do arquivo no `stats`

	})

	O Node.js tamb√©m fornece um m√©todo s√≠ncrono, que bloqueia a thread at√© que os detalhes do arquivo estejam prontos:

	const fs = require('fs')

	try {

	 const stats = fs.statSync('/Users/joe/test.txt')

	} catch (err) {

	 console.error(err)

	}

	As informa√ß√µes do arquivo est√£o inclusas na vari√°vel stats. Que tipos de informa√ß√µes n√≥s podemos extrair usando o stats?

	Muitas, incluindo:

	 	se o arquivo √© um diret√≥rio ou um arquivo, usando stats.isFile() e stats.isDirectory()

	se o arquivo √© um link simb√≥lico, usando stats.isSymbolicLink()

	o tamanho do arquivo, usando stats.size.



	H√° outros m√©todos avan√ßados, mas a maior parte do que voc√™ vai usar na programa√ß√£o do dia a dia s√£o esses.

	const fs = require('fs')

	fs.stat('/Users/joe/test.txt', (err, stats) => {

	 if (err) {

	 console.error(err)

	 return

	 }



	 stats.isFile() // true

	 stats.isDirectory() // false

	 stats.isSymbolicLink() // false

	 stats.size // 1024000 //= 1MB

	})

	Node.js File Paths

	Todo arquivo no sistema tem um caminho.

	No Linux e no macOS, um caminho tem essa cara:

	/users/joe/file.txt

	enquanto que em computadores Windows √© bem diferente, a estrutura √© algo assim:

	C:\users\joe\file.txt

	Voc√™ precisa prestar aten√ß√£o quando est√° utilizando caminhos na sua aplica√ß√£o, as diferen√ßas devem ser levadas em considera√ß√£o.

	Para trabalhar com caminhos, inclua esse m√≥dulo em seus arquivos:

	const path = require('path')

	Obtendo informa√ß√µes de um caminho

	Dado um caminho, voc√™ pode extrair informa√ß√µes dele usando esses m√©todos:

	 	dirname: obt√™m a pasta pai do arquivo

	basename: obt√™m a parte do nome do arquivo

	extname: obt√™m a parte da extens√£o do arquivo



	Exemplo:

	const notes = '/users/joe/notes.txt'



	path.dirname(notes) // /users/joe

	path.basename(notes) // notes.txt

	path.extname(notes) // .txt

	Voc√™ pode obter o nome do arquivo sem a extens√£o ao especificar um segundo argumento no basename:

	path.basename(notes, path.extname(notes)) // notes

	Trabalhando com caminhos

	Voc√™ pode unir duas ou mais partes de um caminho ao utilizar path.join():

	const name = 'joe'

	path.join('/', 'users', name, 'notes.txt') // '/users/joe/notes.txt'

	Voc√™ pode obter o c√°lculo do caminho absoluto de um caminho relativo utilizando path.resolve():

	path.resolve('joe.txt') // '/Users/joe/joe.txt' se rodar a partir da minha pasta home

	Nesse caso o Nodejs vai simplesmente adicionar /joe.txt na pasta atual. Se voc√™ especificar uma pasta como segundo par√¢metro, o resolve vai usar o primeiro como base pro segundo:

	path.resolve('tmp', 'joe.txt') // '/Users/joe/tmp/joe.txt' se rodar a partir da minha pasta home

	Se o primeiro par√¢metro come√ßa com uma barra, isso implica que √© um caminho absoluto:

	path.resolve('/etc', 'joe.txt') // '/etc/joe.txt'

	path.normalize() √© outra fun√ß√£o bem √∫til, que tentar√° calcular o caminho real, quando ele cont√™m especificadores relativos como . ou .., ou barras duplas:

	path.normalize('/users/joe/..//test.txt') // /users/test.txt

	Ambos resolve e normalize n√£o ir√£o validar se o caminho existe. Eles s√≥ calculam um caminho baseado nas informa√ß√µes fornecidas.

	Lendo arquivos com Node.js

	O jeito mais f√°cil de ler um arquivo no Node.js √© utilizar o m√©todo fs.readFile(), passando o caminho do arquivo, a codifica√ß√£o e uma fun√ß√£o callback que ser√° invocada com os dados do arquivo (e o erro):

	const fs = require('fs')



	fs.readFile('/Users/joe/test.txt', 'utf8' , (err, data) => {

	 if (err) {

	 console.error(err)

	 return

	 }

	 console.log(data)

	})

	Alternativamente, voc√™ pode usar a vers√£o s√≠ncrona, fs.readFileSync():

	const fs = require('fs')



	try {

	 const data = fs.readFileSync('/Users/joe/test.txt', 'utf8')

	 console.log(data)

	} catch (err) {

	 console.error(err)

	}

	Ambos fs.readFile() e fs.readFileSync() l√™em todo conte√∫do do arquivo em mem√≥ria antes de retornar os dados.

	Isso significa que arquivos grandes v√£o causar grandes impactos no consumo de mem√≥ria e na velocidade de execu√ß√£o do programa.

	Nesse caso, uma op√ß√£o melhor √© ler o conte√∫do do arquivo usando streams.

	Escrevendo arquivos com Node.js

	O jeito mais f√°cil de escrever em arquivos com Node.js √© utilizando a API fs.writeFile().

	Exemplo:

	const fs = require('fs')



	const content = 'Some content!'



	fs.writeFile('/Users/joe/test.txt', content, err => {

	 if (err) {

	 console.error(err)

	 return

	 }

	 // arquivo escrito com sucesso

	})

	Alternativamente, voc√™ pode usar a vers√£o s√≠ncrona, fs.writeFileSync():

	const fs = require('fs')



	const content = 'Some content!'



	try {

	 const data = fs.writeFileSync('/Users/joe/test.txt', content)

	 // arquivo escrito com sucesso

	} catch (err) {

	 console.error(err)

	}

	Por padr√£o, essa API vai apagar o conte√∫do do arquivo se ele existir. By default, this API will replace the contents of the file if it does already exist.

	Voc√™ pode modificar o comportamento padr√£o especificando uma flag:

	fs.writeFile('/Users/joe/test.txt', content, { flag: 'a+' }, err => {})

	As flags que voc√™ normalmente utilizar√° s√£o

	 	r+ abre o arquivo para leitura e escrita

	w+ abre o arquivo para leitura e escrita, posicionando a stream no in√≠cio do arquivo. O arquivo √© criado se n√£o existir

	a abre o arquivo para escrita, posicionando a stream no fim do arquivo. O arquivo √© criado se n√£o existir

	a+ abre o arquivo para leitura e escrita, posicionando a stream no fim do arquivo. O arquivo √© criado se n√£o existir



	(voc√™ pode encontrar mais flags em https://nodejs.org/api/fs.html#fs_file_system_flags)

	Acrescentar conte√∫do em um arquivo

	Um m√©todo muito √∫til acrescentar conte√∫do no fim de um arquivo √© o fs.appendFile() (e sua contraparte fs.appendFileSync()):

	const content = 'Some content!'



	fs.appendFile('file.log', content, err => {

	 if (err) {

	 console.error(err)

	 return

	 }

	 // feito!

	})

	Usando streams

	Todos esses m√©todos escrevem o conte√∫do completo no arquivo antes de retornarem o controle de volta ao programa (na vers√£o ass√≠ncrona, isso significa executar a callback)

	Nesse caso, uma op√ß√£o melhor √© escrever o conte√∫do do arquivo usando streams.

	Trabalhando com folders no Node.js

	O m√≥dulo nativo fs do Node.js fornece diversos m√©todos vers√°teis para trabalhar com pastas.

	Valide se uma pasta existe

	Utilize fs.access() para validar se a pasta existe e o Node.js pode acess√°-la com suas permiss√µes.

	Crie uma nova pasta

	Utilize fs.mkdir() ou fs.mkdirSync() para criar uma nova pasta.

	const fs = require('fs')



	const folderName = '/Users/joe/test'



	try {

	 if (!fs.existsSync(folderName)) {

	 fs.mkdirSync(folderName)

	 }

	} catch (err) {

	 console.error(err)

	}

	Leia o conte√∫do de um diret√≥rio

	Utilize fs.readdir() ou fs.readdirSync() para ler os conte√∫dos de um diret√≥rio.

	Esse trecho de c√≥digo l√™ o conte√∫do de uma pasta, ambos arquivos e subpastas, e retorna o caminho relativo deles:

	const fs = require('fs')

	const path = require('path')



	const folderPath = '/Users/joe'



	fs.readdirSync(folderPath)

	Voc√™ pode obter o caminho inteiro:

	fs.readdirSync(folderPath).map(fileName => {

	 return path.join(folderPath, fileName)

	})

	Voc√™ tamb√©m pode filtrar os resultados para retornar apenas os arquivos, excluindo as pastas:

	const isFile = fileName => {

	 return fs.lstatSync(fileName).isFile()

	}



	fs.readdirSync(folderPath).map(fileName => {

	 return path.join(folderPath, fileName)

	})

	.filter(isFile)

	Renomeie uma pasta

	Utilize fs.rename() ou fs.renameSync() para renomear uma pasta. O primeiro par√¢metro √© o caminho atual, o segundo o novo caminho:

	const fs = require('fs')



	fs.rename('/Users/joe', '/Users/roger', err => {

	 if (err) {

	 console.error(err)

	 return

	 }

	 // feito

	})

	fs.renameSync() √© a vers√£o s√≠ncrona:

	const fs = require('fs')



	try {

	 fs.renameSync('/Users/joe', '/Users/roger')

	} catch (err) {

	 console.error(err)

	}

	Delete uma pasta

	Utilize fs.rmdir() ou fs.rmdirSync() para deletar uma pasta.

	Deletar uma pasta que tem conte√∫do pode ser mais complicado do que o esperado.

	Nesse caso √© melhor instalar o m√≥dulo fs-extra, que √© bem popular e atualizado. √â uma substitui√ß√£o do m√≥dulo fs, que possui mais funcionalidades.

	Nesse caso o m√©todo que voc√™ quer √© o remove().

	Instale usando

	npm install fs-extra

	e use-o assim:

	const fs = require('fs-extra')



	const folder = '/Users/joe'



	fs.remove(folder, err => {

	 console.error(err)

	})

	Tamb√©m pode ser utilizado com promises:

	fs.remove(folder)

	 .then(() => {

	 //done

	 })

	 .catch(err => {

	 console.error(err)

	 })

	ou com async/await:

	async function removeFolder(folder) {

	 try {

	 await fs.remove(folder)

	 //done

	 } catch (err) {

	 console.error(err)

	 }

	}



	const folder = '/Users/joe'

	removeFolder(folder)

	O m√≥dulo fs

	O m√≥dulo fs disponibiliza diversas funcionalidades √∫teis para acessar e interagir com o file system.

	N√£o h√° necessidade de intal√°-lo. Sendo parte do n√∫cleo do Node.js, basta importar para poder us√°-lo:

	const fs = require('fs')

	Feito isso, voc√™ tem acesso a todos os m√©todos dele, o que inclui:

	 	fs.access(): checa se o arquivo existe e se o Node.js pode acess√°-lo com suas permiss√µes atuais

	fs.appendFile(): acrescenta dados em um arquivo. Se o arquivo n√£o existir, ele √© criado.

	fs.chmod(): muda as permiss√µes de um arquivo especificado pelo nome que foi passado. Relacionado: fs.lchmod(), fs.fchmod()

	fs.chown(): muda o propriet√°rio e o grupo do arquivo especificado pelo nome que foi passado. Relacionado: fs.fchown(), fs.lchown()

	fs.close(): fecha um descriptor de arquivo

	fs.copyFile(): copia um arquivo

	fs.createReadStream(): cria uma stream de arquivo para leitura

	fs.createWriteStream(): cria uma stream de arquivo para escrita

	fs.link(): cria um novo hard link para um arquivo

	fs.mkdir(): cria um novo diret√≥rio

	fs.mkdtemp(): cria um novo diret√≥rio tempor√°rio

	fs.open(): define o file mode

	fs.readdir(): l√™ os conte√∫dos de um diret√≥rio

	fs.readFile(): l√™ os conte√∫dos de um arquivo. Relacionado: fs.read()

	fs.readlink(): l√™ o valor de um link simb√≥lico

	fs.realpath(): resolve caminhos relativos de arquivo com ponteiros (., ..) para o caminho completo

	fs.rename(): renomeia um arquivo ou pasta

	fs.rmdir(): deleta um diret√≥rio

	fs.stat(): retorna o status do arquivo identificado pelo nome que foi passado. Relacionado: fs.fstat(), fs.lstat()

	fs.symlink(): cria um novo link simb√≥lico para um arquivo

	fs.truncate(): trunca o arquivo identificado pelo nome que foi passado para o tamanho especificado. Relacionado: fs.ftruncate()

	fs.unlink(): remove um arquivo ou um link simb√≥lico

	fs.unwatchFile(): para de observar mudan√ßas em um arquivo

	fs.utimes(): muda a timestamp do arquivo identificado pelo nome que foi passado. Relacionado: fs.futimes()

	fs.watchFile(): come√ßa a observar mudan√ßas em um arquivo. Relacionado: fs.watch()

	fs.writeFile(): escreve dados em um arquivo. Relacionado: fs.write()



	Uma coisa peculiar sobre o m√≥dulo fs √© que todos os m√©todos s√£o ass√≠ncronos por padr√£o, mas eles tamb√©m podem rodar de forma s√≠ncrona adicionando Sync no nome.

	Por exemplo:

	 	fs.rename()

	fs.renameSync()

	fs.write()

	fs.writeSync()



	Isso faz uma enorme diferen√ßa no fluxo da sua aplica√ß√£o.

	O Node.js 10 inclui suporte experimental para uma API baseada em promises

	Por exemplo, vamos analisar o m√©todo fs.rename(). A API ass√≠ncrona √© usada com uma callback:

	const fs = require('fs')



	fs.rename('before.json', 'after.json', err => {

	 if (err) {

	 return console.error(err)

	 }



	 // feito

	})

	Uma API s√≠ncrona pode ser usada com um bloco de try/catch para tratar erros:

	const fs = require('fs')



	try {

	 fs.renameSync('before.json', 'after.json')

	 // feito

	} catch (err) {

	 console.error(err)

	}

	A principal diferen√ßa aqui √© que a execu√ß√£o do seu script no segundo exemplo vai bloquear a thread, at√© que a opera√ß√£o no arquivo seja bem-sucedida.

	O m√≥dulo path

	O m√≥dulo path disponibiliza diversas funcionalidades √∫teis para acessar e interagir com o file system.

	N√£o h√° necessidade de intal√°-lo. Sendo parte do n√∫cleo do Node.js, basta importar para poder us√°-lo:

	const path = require('path')

	Esse m√≥dulo possui o path.sep que prov√™ o caracter separador de segmento de caminho (\ no Windows, e / no Linux / macOS), e o path.delimiter que prov√™ o caracter delimitador de caminho (; no Windows, e : no Linux / macOS).

	Esses s√£o os m√©todos do path:

	path.basename()

	Retorna a √∫ltima parte de um caminho. Um segundo par√¢metro pode filtrar a extens√£o do arquivo:

	require('path').basename('/test/something') // something

	require('path').basename('/test/something.txt') // something.txt

	require('path').basename('/test/something.txt', '.txt') // something

	path.dirname()

	Retorna a parte do diret√≥rio de um caminho:

	require('path').dirname('/test/something') // /test

	require('path').dirname('/test/something/file.txt') // /test/something

	path.extname()

	Retorna a parte da extens√£o de um caminho

	require('path').extname('/test/something') // ''

	require('path').extname('/test/something/file.txt') // '.txt'

	path.isAbsolute()

	Retorna true se o caminho for absoluto

	require('path').isAbsolute('/test/something') // true

	require('path').isAbsolute('./test/something') // false

	path.join()

	Junta duas ou mais partes de um caminho:

	const name = 'joe'

	require('path').join('/', 'users', name, 'notes.txt') // '/users/joe/notes.txt'

	path.normalize()

	Tenta calcular o caminho correto quando ele cont√™m especificadores relativos como . ou .., ou barras duplas:

	require('path').normalize('/users/joe/..//test.txt') // '/users/test.txt'

	path.parse()

	Cria um objeto contendo os segmentos que comp√µes o caminho fornecido:

	 	root: a raiz

	dir: o caminho da pasta a partir da raiz

	base: o nome do arquivo + extens√£o

	name: o nome do arquivo

	ext: a extens√£o do arquivo



	Exemplo:

	require('path').parse('/users/test.txt')

	resulta em

	{

	 root: '/',

	 dir: '/users',

	 base: 'test.txt',

	 ext: '.txt',

	 name: 'test'

	}

	path.relative()

	Aceita 2 caminhos como argumentos. Retorna o caminho relativo do primeiro para o segundo, baseando-se no diret√≥rio atual.

	Exemplo:

	require('path').relative('/Users/joe', '/Users/joe/test.txt') // 'test.txt'

	require('path').relative('/Users/joe', '/Users/joe/something/test.txt') // 'something/test.txt'

	path.resolve()

	Voc√™ pode obter o c√°lculo do caminho absoluto de um caminho relativo usando path.resolve():

	path.resolve('joe.txt') // '/Users/joe/joe.txt' se rodar da minha home

	Ao especificar um segundo par√¢metro, o resolve vai usar o primeiro como base para o segundo:

	path.resolve('tmp', 'joe.txt') // '/Users/joe/tmp/joe.txt' se rodar da minha home

	Se o primeiro par√¢metro come√ßar com uma barra, isso significa que √© um caminho absoluto:

	path.resolve('/etc', 'joe.txt') // '/etc/joe.txt'

	O M√≥dulo OS

	Esse m√≥dulo disponibiliza diversas fun√ß√µes que voc√™ pode usar para obter informa√ß√µes do sistema operacional e do computador em que o programa est√° executando, e interagir com ele.

	const os = require('os')

	H√° algumas propriedades √∫teis que nos dizem algumas coisas importantes relacionadas a manipula√ß√£o de arquivos:

	os.EOL retorna o a sequ√™ncia delimitadora de linha (caracter de pular linha). \n no Linux e macOS, e \r\n no Windows.

	os.constants.signals retorna todas contantes relacionadas a sinais de processos, como SIGHUP, SIGKILL e outros.

	os.constants.errno define as constantes para reportar erros, como EADDRINUSE, EOVERFLOW e mais outras.

	Voc√™ pode ver todas constantes em https://nodejs.org/api/os.html#os_signal_constants.

	Agora vamos ver os principais m√©todos do os:

	os.arch()

	Retorna uma string que identifica a arquitetura, como arm, x64, arm64.

	os.cpus()

	Retorna informa√ß√µes sobre as CPUs dispon√≠vels no seu sistema.

	Exemplo:

	[

	 {

	 model: 'Intel(R) Core(TM)2 Duo CPU P8600 @ 2.40GHz',

	 speed: 2400,

	 times: {

	 user: 281685380,

	 nice: 0,

	 sys: 187986530,

	 idle: 685833750,

	 irq: 0

	 }

	 },

	 {

	 model: 'Intel(R) Core(TM)2 Duo CPU P8600 @ 2.40GHz',

	 speed: 2400,

	 times: {

	 user: 282348700,

	 nice: 0,

	 sys: 161800480,

	 idle: 703509470,

	 irq: 0

	 }

	 }

	]

	os.endianness()

	Retorna BE ou LE dependendo se o Node.js foi compilado com Big Endian ou Little Endian.

	os.freemem()

	Retorna o n√∫mero de bytes que representam a mem√≥ria livre no seu sistema.

	os.homedir()

	Retorna o caminho do diret√≥rio home do usu√°rio corrente.

	Exemplo:

	'/Users/joe'

	os.hostname()

	Retorna o host name.

	os.loadavg()

	Retorna o c√°lculo feito pelo sistema operacional na m√©dia de carregamento.

	S√≥ retorna um valor significativo no Linux e no macOS.

	Exemplo:

	[3.68798828125, 4.00244140625, 11.1181640625]

	os.networkInterfaces()

	Retorna os detalhes das interfaces de rede dispon√≠veis no seu sistema.

	Exemplo:

	{ lo0:

	 [ { address: '127.0.0.1',

	 netmask: '255.0.0.0',

	 family: 'IPv4',

	 mac: 'fe:82:00:00:00:00',

	 internal: true },

	 { address: '::1',

	 netmask: 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff',

	 family: 'IPv6',

	 mac: 'fe:82:00:00:00:00',

	 scopeid: 0,

	 internal: true },

	 { address: 'fe80::1',

	 netmask: 'ffff:ffff:ffff:ffff::',

	 family: 'IPv6',

	 mac: 'fe:82:00:00:00:00',

	 scopeid: 1,

	 internal: true } ],

	 en1:

	 [ { address: 'fe82::9b:8282:d7e6:496e',

	 netmask: 'ffff:ffff:ffff:ffff::',

	 family: 'IPv6',

	 mac: '06:00:00:02:0e:00',

	 scopeid: 5,

	 internal: false },

	 { address: '192.168.1.38',

	 netmask: '255.255.255.0',

	 family: 'IPv4',

	 mac: '06:00:00:02:0e:00',

	 internal: false } ],

	 utun0:

	 [ { address: 'fe80::2513:72bc:f405:61d0',

	 netmask: 'ffff:ffff:ffff:ffff::',

	 family: 'IPv6',

	 mac: 'fe:80:00:20:00:00',

	 scopeid: 8,

	 internal: false } ] }

	os.platform()

	Retorna a plataforma em que o Node.js foi compilado:

	 	darwin

	freebsd

	linux

	openbsd

	win32

	‚Ä¶outros



	os.release()

	Retorna uma string que identifica o n√∫mero da vers√£o do sistema operacional

	os.tmpdir()

	Retorna o caminho da pasta temp atribuida.

	os.totalmem()

	Retorna o n√∫mero de bytes que representam o total de mem√≥ria dispon√≠vel no sistema.

	os.type()

	Identifica o sistema operacional:

	 	Linux

	Darwin no macOS

	Windows_NT no Windows



	os.uptime()

	Retorna o n√∫mero de segundos em que o computador est√° rodando desde o √∫ltimo rein√≠cio.

	os.userInfo()

	Retorna um objeto contendo o username corrente, uid, gid, shell, e homedir

	O m√≥dulo de eventos

	O m√≥duo events nos disponibiliza a classe EventEmitter, que √© essencial para trabalhar com eventos no Node.js.

	const EventEmitter = require('events')

	const door = new EventEmitter()

	O event listener usa esses eventos:

	 	newListener quando um listener √© adicionado

	removeListener quando um listener √© removido



	Aqui detamos uma descri√ß√£o detalhade dos m√©todos mais usados:

	emitter.addListener()

	Alias para emitter.on().

	emitter.emit()

	Emite um evento. Chama sincronamente todo event listener na ordem em que foram registrados.

	door.emit("slam") // emitindo o evento "slam"

	emitter.eventNames()

	Retorna um array de string que representa os eventos regstrados no objeto EventEmitter atual:

	door.eventNames()

	emitter.getMaxListeners()

	Obt√™m a quantidade m√°xima de listeners que podem ser adicionados em um objeto EventEmitter, que por padr√£o √© 10 mas pode ser aumentado ou diminuido utilizando setMaxListeners()

	door.getMaxListeners()

	emitter.listenerCount()

	Obt√™m a contagem total de listeners do evento passado como par√¢metro:

	door.listenerCount('open')

	emitter.listeners()

	Obt√™m um array de listeners do evento passado como par√¢metro:

	door.listeners('open')

	emitter.off()

	Alias para emitter.removeListener() adicionado no Node.js 10

	emitter.on()

	Adiciona uma fun√ß√£o callback que √© chamada quando um evento √© emitido.

	Uso:

	door.on('open', () => {

	 console.log('Door was opened')

	})

	emitter.once()

	Adiciona uma fun√ß√£o callback que ser√° chamada quando um evento for emitido pela primeira vez depois de registrado. Essa callback s√≥ ser√° chamada uma vez.

	const EventEmitter = require('events')

	const ee = new EventEmitter()



	ee.once('my-event', () => {

	 // chama a fun√ß√£o callback uma vez

	})

	emitter.prependListener()

	Quando voc√™ adiciona um listener usando on ou addListener, ele √© adicionado no fim da fila de listener, e chamado por √∫ltimo. Usando preprendListener ele ser√° adicionado, e chamado, antes dos outros listeners.

	emitter.prependOnceListener()

	Quando voc√™ adiciona um listener usando once, ele √© adicionado na fila de listeners, e chamado por √∫ltimo. Usando prependOnceListener ele √© adicionado, e chamado, antes dos outros listeners.

	emitter.removeAllListeners()

	Remove todos os listeners de um objeto EventEmitter escutando um evento em espec√≠fico:

	door.removeAllListeners('open')

	emitter.removeListener()

	Remove um listener em espec√≠fico. Voc√™ pode fazer isso salvando a fun√ß√£o callback em uma vari√°vel, quando adicionada, ela pode ser referenciada mais tarde:

	const doSomething = () => {}

	door.on('open', doSomething)

	door.removeListener('open', doSomething)

	emitter.setMaxListeners()

	Define a quantidade m√°xima de listeners que podem ser adicionados em um objeto EventEmitter, que por padr√£o √© 10 mas pode ser aumentado ou diminuido.

	door.setMaxListeners(50)

	M√≥dulo HTTP

	O m√≥dulo HTTP √© um m√≥dulo essencial para aplica√ß√µes de rede em Node.js.

	Ele pode ser importado assim:

	const http = require('http')

	O m√≥dulo disponibiliza algumas propriedades e m√©todos, e tamb√©m algumas classes.

	Properties

	http.METHODS

	Essa propriedade lista todos os m√©todos HTTP suportados:

	> require('http').METHODS

	[ 'ACL',

	 'BIND',

	 'CHECKOUT',

	 'CONNECT',

	 'COPY',

	 'DELETE',

	 'GET',

	 'HEAD',

	 'LINK',

	 'LOCK',

	 'M-SEARCH',

	 'MERGE',

	 'MKACTIVITY',

	 'MKCALENDAR',

	 'MKCOL',

	 'MOVE',

	 'NOTIFY',

	 'OPTIONS',

	 'PATCH',

	 'POST',

	 'PROPFIND',

	 'PROPPATCH',

	 'PURGE',

	 'PUT',

	 'REBIND',

	 'REPORT',

	 'SEARCH',

	 'SUBSCRIBE',

	 'TRACE',

	 'UNBIND',

	 'UNLINK',

	 'UNLOCK',

	 'UNSUBSCRIBE' ]

	http.STATUS_CODES

	Essa propriedade lista todos os c√≥digos de status HTTP e suas descri√ß√µes:

	> require('http').STATUS_CODES

	{ '100': 'Continue',

	 '101': 'Switching Protocols',

	 '102': 'Processing',

	 '200': 'OK',

	 '201': 'Created',

	 '202': 'Accepted',

	 '203': 'Non-Authoritative Information',

	 '204': 'No Content',

	 '205': 'Reset Content',

	 '206': 'Partial Content',

	 '207': 'Multi-Status',

	 '208': 'Already Reported',

	 '226': 'IM Used',

	 '300': 'Multiple Choices',

	 '301': 'Moved Permanently',

	 '302': 'Found',

	 '303': 'See Other',

	 '304': 'Not Modified',

	 '305': 'Use Proxy',

	 '307': 'Temporary Redirect',

	 '308': 'Permanent Redirect',

	 '400': 'Bad Request',

	 '401': 'Unauthorized',

	 '402': 'Payment Required',

	 '403': 'Forbidden',

	 '404': 'Not Found',

	 '405': 'Method Not Allowed',

	 '406': 'Not Acceptable',

	 '407': 'Proxy Authentication Required',

	 '408': 'Request Timeout',

	 '409': 'Conflict',

	 '410': 'Gone',

	 '411': 'Length Required',

	 '412': 'Precondition Failed',

	 '413': 'Payload Too Large',

	 '414': 'URI Too Long',

	 '415': 'Unsupported Media Type',

	 '416': 'Range Not Satisfiable',

	 '417': 'Expectation Failed',

	 '418': 'I\'m a teapot',

	 '421': 'Misdirected Request',

	 '422': 'Unprocessable Entity',

	 '423': 'Locked',

	 '424': 'Failed Dependency',

	 '425': 'Unordered Collection',

	 '426': 'Upgrade Required',

	 '428': 'Precondition Required',

	 '429': 'Too Many Requests',

	 '431': 'Request Header Fields Too Large',

	 '451': 'Unavailable For Legal Reasons',

	 '500': 'Internal Server Error',

	 '501': 'Not Implemented',

	 '502': 'Bad Gateway',

	 '503': 'Service Unavailable',

	 '504': 'Gateway Timeout',

	 '505': 'HTTP Version Not Supported',

	 '506': 'Variant Also Negotiates',

	 '507': 'Insufficient Storage',

	 '508': 'Loop Detected',

	 '509': 'Bandwidth Limit Exceeded',

	 '510': 'Not Extended',

	 '511': 'Network Authentication Required' }

	http.globalAgent

	Aponta para a inst√¢ncia global do objeto Agente, que √© uma inst√Çncia da classe http.Agent.

	√â usado para gerenciar persist√™ncia de conex√µes e reuso para clientes HTTP.

	Veremos mais da descri√ß√£o da classe http.Agent.

	Methods

	http.createServer()

	Retorna uma nova inst√¢ncia da classe http.Server.

	Uso:

	const server = http.createServer((req, res) => {

	 // gerencie cada requisi√ß√£o com essa callback

	})

	http.request()

	Faz uma requisi√ß√£o HTTP para um servidor, criando uma inst√¢ncia da classe http.ClientRequest.

	http.get()

	Parecido com o http.request(), mas define automaticamente o verbo HTTP para GET, e chama req.end() automaticamente.

	Classes

	O m√≥dulo HTTP prov√™ 5 classes:

	 	http.Agent

	http.ClientRequest

	http.Server

	http.ServerResponse

	http.IncomingMessage



	http.Agent

	O Node.js cria uma inst√¢ncia global da classe http.Agent para gerenciar persist√™ncia de conex√µes e reuso para clientes HTTP.

	Esse objeto garante que toda requisi√ß√£o feita ao servidor seja enfileirada e um √∫nico socket seja reusado.

	Tamb√©m mant√©m um pool de sockets. Isso √© necess√°rio por raz√µes de performance.

	http.ClientRequest

	Um objeto http.ClientRequest √© criado quando http.request() ou http.get() s√£o chamados.

	Quando uma resposta √© recebida, o evento response √© chamado com a resposta, contendo uma inst√¢ncia de http.IncomingMessage como argumento.

	Os dados retornados de uma resposta podem ser lidos de 2 formas:

	 	voc√™ pode chamar o m√©todo response.read()

	na callback do evento response voc√™ pode preparar um event listener para o evento data, assim voc√™ pode ouvir os dados transmitidos.



	http.Server

	Essa classe √© comumente instanciada e retornada quando se cria um novo servidor usando http.createServer().

	Uma vez que voc√™ tenha um objeto server, voc√™ pode acessar os m√©todos dele:

	 	close() impede o servidor de aceitar novas conex√µes

	listen() inicia o servidor HTTP e escuta as conex√µes



	http.ServerResponse

	Criado por um http.Server e passado como segundo par√¢metro para o evento request acionado.

	Normalmente √© usado com o res:

	const server = http.createServer((req, res) => {

	 // res √© um objeto http.ServerResponse

	})

	Voc√™ sempre deve chamar o m√©todo end() na callback, que fecha a response, a mensagem est√° completa e o servidor pode envi√°-la ao client. Deve ser chamado em cada response.

	Esses m√©todos s√£o usados para interagir com headers HTTP:

	 	getHeaderNames() obt√™m a lista de nomes das headers HTTP j√° definidas

	getHeaders() obt√™m uma c√≥pia das headers HTTP j√° definidas

	setHeader('headername', value) define uma header HTTP e seu valor

	getHeader('headername') obt√™m uma header HTTP j√° definida

	removeHeader('headername') remove uma header HTTP j√° definida

	hasHeader('headername') retorna true se a response j√° cont√™m aquela header

	headersSent() retorna true se as headers j√° foram enviadas ao client



	Depois de processar as headers voc√™ pode envi√°-las ao client chamando response.writeHead(), que aceita o statusCode como primeiro par√¢metro, e mensagem do status de forma opcional, e o objeto de headers.

	Para enviar os dados ao client pelo body da response, voc√™ usa write(). Ele enviar√° os dados armazenados em buffer para a stream de resposta HTTP.

	Se os headers ainda n√£o foram enviados usando response.writeHead(), as headers ser√£o enviadas primeiro, com o c√≥digo de status e a mensagem que foram definidos na request, que voc√™ pode editar definindo os valores das propriedades statusCode e statusMessage:

	response.statusCode = 500

	response.statusMessage = 'Internal Server Error'

	http.IncomingMessage

	Um objeto http.IncomingMessage √© criado quando:

	 	http.Server est√° escutando o evento request

	http.ClientRequest est√° escutando o evento response



	Pode ser usado para acessar da response:

	 	status usando os m√©todos statusCode e statusMessage

	headers usando o m√©todo headers ou rawHeaders

	m√©todo HTTP usando o m√©todo method

	vers√£o HTTP usando o m√©todo httpVersion

	URL usando o m√©todo url

	socket subjacente usando o m√©todo socket



	Os dados s√£o acessados usando streams, uma vez que http.IncomingMessage implementa a interface Readable Stream.

	Buffers no Node.js

	O que √© um buffer?

	Um buffer √© uma √°rea de mem√≥ria. Desenvolvedores JavaScript n√£o s√£o familiarizados com esse conceito, muito menos que desenvolvedores C, C++ ou Go (ou qualquer programador que use uma linguagem de programa√ß√£o de sistema), que interagem com mem√≥ria diariamente.

	Ele representa um peda√ßo de mem√≥ria de tamanho fixo (n√£o pode ser redimensionado) alocado fora da engine JavaScript V8.

	Voc√™ pode pensar em um buffer com um array de inteiros, em que cada um representa um byte de dados.

	Ele √© implementado pela classe Buffer no Node.js.

	Por que precisamos de um buffer?

	Buffers foram introduzidos para ajudar desenvolvedores a lidar com dados bin√°rios, em um ecossistema que tradicionalmente s√≥ lida com strings em vez de bin√°rios.

	Buffers s√£o profundamente linkados com streams. Quando um processador de stream recebe mais r√°pido do que pode aguentar, ele coloca os dados em um buffer.

	Uma visualiza√ß√£o simples de um buffer √© quando voc√™ est√° assistindo um v√≠deo no Youtube e a linha vermelha vai al√©m do seu ponto de visualiza√ß√£o: voc√™ est√° baixando dados mais r√°pido do que est√° os vendo, e o seu browser os bufferiza.

	Como criar um buffer

	Um buffer √© criado usando os m√©todos Buffer.from(), Buffer.alloc(), e Buffer.allocUnsafe().

	const buf = Buffer.from('Hey!')

	 	Buffer.from(array)

	Buffer.from(arrayBuffer[, byteOffset[, length]])

	Buffer.from(buffer)

	Buffer.from(string[, encoding])



	Voc√™ tamb√©m pode inicializar passando apenas o tamanho. Isso cria um buffer de 1KB:

	const buf = Buffer.alloc(1024)

	//or

	const buf = Buffer.allocUnsafe(1024)

	Enquanto ambos alloc e allocUnsafe alocam um Buffer do tamanho especificado em bytes, o Buffer criado via alloc vai ser inicializado com zeros e o criado via allocUnsafe vai ser n√£o inicializado. Isso significa que enquanto allocUnsafe pode ser bem r√°pido em compara√ß√£o ao alloc, o segmento de mem√≥ria alocado pode conter dados antigos que podem ser potencialmente sens√≠veis.

	Dados antigos, se presentes em mem√≥ria, podem ser acessados ou vazados quando a mem√≥ria do Buffer √© lida. Isso √© o que realmente faz do allocUnsafe inseguro e tenha cuidado extra ao us√°-lo.

	Usando um buffer

	Acessando o conte√∫do de um buffer

	Um buffer, sendo um array de bytes, pode ser acessado como um array:

	const buf = Buffer.from('Hey!')

	console.log(buf[0]) // 72

	console.log(buf[1]) // 101

	console.log(buf[2]) // 121

	Esses n√∫meros s√£o o C√≥digo Unicode que identifica o caracter naquela posi√ß√£o do buffer (H => 72, e => 101, y => 121)

	Voc√™ pode imprimir o conte√∫do completo de um buffer usando o m√©todo toString():

	console.log(buf.toString())

	Observe que se voc√™ inicializar um buffer com um n√∫mero que defina o tamanho dele, voc√™ vai ter acesso √† mem√≥ria pre-inicializada, que vai conter dados aleat√≥rios, n√£o um buffer vazio!

	Obtendo o comprimento de um buffer

	Use a propriedade length:

	const buf = Buffer.from('Hey!')

	console.log(buf.length)

	Iterando sob o conte√∫do de um buffer

	const buf = Buffer.from('Hey!')

	for (const item of buf) {

	 console.log(item) // 72 101 121 33

	}

	Mudando o conte√∫do de um buffer

	Voc√™ pode gravar uma string inteira de dados em um buffer usando o m√©todo write():

	const buf = Buffer.alloc(4)

	buf.write('Hey!')

	Assim como voc√™ pode acessar um buffer com uma sintaxe de array, voc√™ tamb√©m pode definir os conte√∫dos do buffer dessa mesma forma:

	const buf = Buffer.from('Hey!')

	buf[1] = 111 // o

	console.log(buf.toString()) // Hoy!

	Copiando um buffer

	√â poss√≠vel copiar um buffer usando o m√©todo copy():

	const buf = Buffer.from('Hey!')

	let bufcopy = Buffer.alloc(4) // allocate 4 bytes

	buf.copy(bufcopy)

	Por padr√£o voc√™ copia o buffer inteiro. Mais 3 par√¢metros deixam voc√™ definir a posi√ß√£o inicial, a posi√ß√£o final, e o comprimento do novo buffer:

	const buf = Buffer.from('Hey!')

	let bufcopy = Buffer.alloc(2) // allocate 2 bytes

	buf.copy(bufcopy, 0, 0, 2)

	bufcopy.toString() // 'He'

	Fatiando um buffer

	Se voc√™ quer criar uma visualiza√ß√£o parccial de um buffer, voc√™ pode criar uma fatia (slice). Uma fatia n√£o √© uma c√≥pia: o buffer original ainda √© a fonte de verdade. Se ele mudar, sua fatia tamb√©m muda.

	Use o m√©todo slice() para criar a fatia. O primeiro par√¢metro √© a posi√ß√£o inicial, e voc√™ pode especificar um segundo par√¢metro opcional com a posi√ß√£o final:

	const buf = Buffer.from('Hey!')

	buf.slice(0).toString() // Hey!

	const slice = buf.slice(0, 2)

	console.log(slice.toString()) // He

	buf[1] = 111 // o

	console.log(slice.toString()) // Ho

	Node.js Streams

	O que s√£o streams

	Streams s√£o um dos conceitos fundamentais que empoderam aplica√ß√µes Node.js.

	Elas s√£o um jeito de lidar com leitura/escrita de arquivos, comunica√ß√µes em rede, ou qualquer tipo de troca de informa√ß√£o end-to-end de uma forma eficiente.

	Streams n√£o s√£o um conceito √∫nico do Node.js. Elas foram introduzidas no sistema operacional Unix d√©cadas atr√°s, permitindo que programas possam interagir uns com os outros passando streams, atrav√©s do operador pipe (|).

	Por exemplo, em uma abordagem tradicional, quando voc√™ diz ao programa para ler um arquivo, o arquivo √© lido na mem√≥ria, do come√ßo ao fim, e ent√£o √© processado.

	Utilizando streams voc√™ l√™ peda√ßo por peda√ßo, processando o conte√∫do sem mant√™-lo completo na mem√≥ria.

	O m√≥dulo stream prov√™ a funda√ß√£o da qual todas APIs de streaming s√£o feitas. Todas streams s√£o inst√¢ncias do EventEmitter

	Porqu√™ streams

	Streams basicamente nos d√£o duas grandes vantagens sobre outros m√©todos de manipula√ß√£o de dados:

	 	Efici√™ncia de mem√≥ria: voc√™ n√£o precisa carregar grandes quantidades de dados em mem√≥ria antes de ser capaz de process√°-los

	Efici√™ncia temporal: menos tempo √© requerido para come√ßar a processar dados, uma vez que voc√™ pode come√ßar a processar assim que os tiver, em vez de esperar at√© que toda carga √∫til de dados esteja dispon√≠vel



	Um exemplo de stream

	Um exemplo t√≠pico √© ler arquivos de um disco.

	Usando o m√≥dulo fs do Node.js, voc√™ pode ler um arquivo, e serv√≠-lo com HTTP quando uma nova conex√£o √© estabelecida no seu servidor HTTP:

	const http = require('http')

	const fs = require('fs')



	const server = http.createServer(function(req, res) {

	 fs.readFile(__dirname + '/data.txt', (err, data) => {

	 res.end(data)

	 })

	})

	server.listen(3000)

	readFile() l√™ todo conte√∫do do arquivo, e invoca uma fun√ß√£o callback quando terminar.

	res.end(data) na callbac vai retornar o conte√∫do do arquivo para o client HTTP.

	Se o arquivo for grande, a opera√ß√£o vai demorar um pouco. Aqui temos a mesma funcionalidade usando streams:

	const http = require('http')

	const fs = require('fs')



	const server = http.createServer((req, res) => {

	 const stream = fs.createReadStream(__dirname + '/data.txt')

	 stream.pipe(res)

	})

	server.listen(3000)

	Em vez de esperar at√© que o arquivo seja completamente lido, n√≥s come√ßamos a ‚Äústream√°-lo‚Äù para o client HTTP assim que tivermos chunks de dados prontos para serem enviados.

	pipe()

	O exemplo acima usa stream.pipe(res): o m√©todo pipe() √© chamado na stream de arquivo.

	O que esse c√≥digo faz? Ele pega a origem, e canaliza para um destino.

	Voc√™ chama isso na stream origem, e nesse caso, a stream de arquivo √© canalizada para a resposta HTTP.

	O valor retornado pelo m√©todo pipe() √© a stream de destino, que √© algo muito conveniente pois nos permite encadear m√∫ltiplas chamadas pipe(), desse jeito:

	src.pipe(dest1).pipe(dest2)

	Isso faz o mesmo que

	src.pipe(dest1)

	dest1.pipe(dest2)

	APIs Node.js baseadas em streams

	Dadas as suas vantagens, muitos dos m√≥dulos principais do Node.js fornecem recursos nativos para manipula√ß√£o de streams, sendo os mais not√°veis:

	 	process.stdin retorna uma stream conectada ao stdin

	process.stdout retorna uma stream conectada ao stdout

	process.stderr retorna uma stream conectada ao stderr

	fs.createReadStream() cria uma stream de leitura para um arquivo

	fs.createWriteStream() cria uma stream de escrita para um arquivo

	net.connect() inicia uma stream baseada em conex√£o

	http.request() retorna uma inst√¢ncia da classe http.ClientRequest, que √© uma stream de escrita

	zlib.createGzip() comprime dados usando gzip (um algoritmo de compress√£o) em uma stream

	zlib.createGunzip() descomprime uma stream gzip.

	zlib.createDeflate() comprime dados usando deflate (um algoritmo de compress√£o) em uma stream

	zlib.createInflate() descomprime uma stream deflate.



	Diferentes tipos de streams

	Existem quatro classes de streams:

	 	Readable: uma stream de onde voc√™ pode canalizar, mas n√£o canalizar dados nela (voc√™ pode receber dados, mas n√£o pode enviar dados). Quando voc√™ coloca dados em uma stream de leitura, os dados s√£o bufferizados, at√© que um consumer comece a ler os dados.

	Writable: uma stream em que voc√™ pode canalizar dados, mas n√£o obter dados dela (voc√™ pode enviar dados, mas n√£o pode receber).

	Duplex: uma stream em que voc√™ pode tanto canalizar dados quando obt√™-los, basicamente uma combina√ß√£o de uma stream Readable e uma Writable

	Transform: uma stream Transform √© similar a uma Duplex, mas a sa√≠da √© um transform das entradas



	Como criar uma stream de leitura (readable stream)

	N√≥s obt√™mos a stream de leitura pelo m√≥dulo stream, a inicializamos e implementamos o m√©todo readable._read().

	Primeiro crie um objeto stream:

	const Stream = require('stream')

	const readableStream = new Stream.Readable()

	ent√£o implemente o _read:

	readableStream._read = () => {}

	Voc√™ tamb√©m pode implementar o _read usando a op√ß√£o read:

	const readableStream = new Stream.Readable({

	 read() {}

	})

	Agora que a stream est√° inicializada, n√≥s podemos enviar dados a ela:

	readableStream.push('hi!')

	readableStream.push('ho!')

	Como criar uma stream de escrita (writable stream)

	Para criar uma stream de escrita n√≥s extendemos o objeto base Writable, e implementamos seu m√©todo _write().

	Primeiro crie um objeto stream:

	const Stream = require('stream')

	const writableStream = new Stream.Writable()

	e ent√£o implemente o _write:

	writableStream._write = (chunk, encoding, next) => {

	 console.log(chunk.toString())

	 next()

	}

	Agora voc√™ pode canalizar uma stream de leitura nele:

	process.stdin.pipe(writableStream)

	Como obt√™r dados de uma stream de leitura

	Como n√≥s lemos dados de uma stream de leitura? Usando uma stream de escrita:

	const Stream = require('stream')



	const readableStream = new Stream.Readable({

	 read() {}

	})

	const writableStream = new Stream.Writable()



	writableStream._write = (chunk, encoding, next) => {

	 console.log(chunk.toString())

	 next()

	}



	readableStream.pipe(writableStream)



	readableStream.push('hi!')

	readableStream.push('ho!')

	Voc√™ tamb√©m pode consumir uma stream de leitura diretamente, usando o evento readble:

	readableStream.on('readable', () => {

	 console.log(readableStream.read())

	})

	Como enviar dados para uma stream de escrita

	Usando o m√©todo write() da stream:

	writableStream.write('hey!\n')

	Sinalizando a uma stream de escrita que voc√™ terminou de escrever

	Use o m√©todo end():

	const Stream = require('stream')



	const readableStream = new Stream.Readable({

	 read() {}

	})

	const writableStream = new Stream.Writable()



	writableStream._write = (chunk, encoding, next) => {

	 console.log(chunk.toString())

	 next()

	}



	readableStream.pipe(writableStream)



	readableStream.push('hi!')

	readableStream.push('ho!')



	writableStream.end()

	A diferen√ßa entre development e production

	Voc√™ pode ter configura√ß√µes diferentes para os ambientes de produ√ß√£o e desenvolvimento.

	O Node.js assume que voc√™ est√° sempre rodando de um ambiente de desenvolvimento.

	Voc√™ pode sinalizar ao Node.js que est√° rodando em produ√ß√£o definindo a vari√°vel de ambiente NODE_ENV=production.

	Isso normalmente √© feito executando o comando

	export NODE_ENV=production

	no shell, mas √© melhor colocar no seu arquivo de configura√ß√£o shell (bash_profile com Bash shell), porque sen√£o a configura√ß√£o n√£o √© persistida em caso de rein√≠cio do sistema.

	Voc√™ tamb√©m pode aplicar a vari√°vel de ambiente prefixando no comando de inicializa√ß√£o da sua aplica√ß√£o:

	NODE_ENV=production node app.js

	Essa vari√°vel de ambiente √© uma conven√ß√£o amplamente usada por bibliotecas tamb√©m.

	Definir o ambiente para production geralmente garante que

	 	√© mantido o m√≠nimo de logs, apenas o essencial

	mais n√≠veis de cache s√£o usados para otimizar a performance



	Tomando como exemplo o Pug, a biblioteca de templates usada pelo Express, compila em modo debug se NODE_ENV n√£o estiver definida como production. No ambiente de desenvolvimento as views do Express s√£o compiladas em cada requisi√ß√£o, enquanto que em produ√ß√£o elas s√£o cacheadas. H√° muitos outros exemplos al√©m desse.

	Voc√™ pode usar condicionais para executar c√≥digos em ambientes diferentes:

	if (process.env.NODE_ENV === "development") {

	 //...

	}

	if (process.env.NODE_ENV === "production") {

	 //...

	}

	if(['production', 'staging'].indexOf(process.env.NODE_ENV) >= 0) {

	 //...

	})

	Por exemplo, em uma aplica√ß√£o Express, voc√™ pode usar isso para definir o errorHandler de acordo com o ambiente:

	if (process.env.NODE_ENV === "development") {

	 app.use(express.errorHandler({ dumpExceptions: true, showStack: true }))

	})



	if (process.env.NODE_ENV === "production") {

	 app.use(express.errorHandler())

	})

	Error handling no Node.js

	Erros no Node.js s√£o tratados por meio de exce√ß√µes.

	Criando exce√ß√µes

	Uma exce√ß√£o √© crianda usando a palavra reservada throw:

	throw value

	Assim que o JavaScript executa essa linha, o fluxo normal do programa √© parado e o controle √© retomado pelo tratamento de exce√ß√£o mais pr√≥ximo.

	Normalmente no c√≥digo client-side o value pode ser qualquer valor JavaScript, incluindo uma string, um n√∫mero ou um objeto.

	No Node.js, n√≥s n√£o lan√ßamos strings, s√≥ lan√ßamos objetos de erro.

	Objetos de erro

	Um objeto de erro √© um objeto que √© uma inst√¢ncia do objeto Error, ou que estenda a classe Error, fornecida pelo m√≥dulo nativo Error:

	throw new Error('Ran out of coffee')

	ou

	class NotEnoughCoffeeError extends Error {

	 // ...

	}

	throw new NotEnoughCoffeeError()

	Tratando exce√ß√µes

	Um bloco try/catch √© um tratador de exce√ß√µes.

	Qualquer exce√ß√£o lan√ßada nas linhas que incluem o bloco try ser√£o tratadas no bloco catch correspondente:

	try {

	 // linhas de c√≥digo

	} catch (e) {}

	e nesse excemplo √© o valor da exce√ß√£o.

	Voc√™ pode adicionar m√∫ltiplos blocos, que podem tratar diferentes tipos de erros.

	Pegando exce√ß√µes n√£o capturadas

	Se uma exce√ß√£o n√£o capturada for lan√ßada durante a execu√ß√£o do seu programa, ele ir√° crashar.

	Para resolver isso, escute o evento uncaughtException no objeto process:

	process.on('uncaughtException', err => {

	 console.error('There was an uncaught error', err)

	 process.exit(1) // obrigat√≥rio (conforme as docs do Node.js)

	})

	Voc√™ n√£o precisa importar o m√≥dulo nativo process, ele √© automaticamente injetado.

	Exce√ß√µes com promises

	Usando promises voc√™ pode encadear diferentes opera√ß√µes, e tratar erros no final:

	doSomething1()

	 .then(doSomething2)

	 .then(doSomething3)

	 .catch(err => console.error(err))

	Como voc√™ sabe quando o erro ocorreu? Voc√™ na verdade n√£o sabe, mas voc√™ pode tratar erros em cada uma das fun√ß√µes que chamar (doSomethingX), e dentro do catch lan√ßar um novo erro, que chamar√° o catch exterior:

	const doSomething1 = () => {

	 //...

	 try {

	 //...

	 } catch (err) {

	 //... trata o erro localmente

	 throw new Error(err.message)

	 }

	 //...

	}

	Para ser poss√≠vel tratar erros localmente sem trat√°-los na fun√ß√£o que chamamos, n√≥s podemos quebrar a corrente, voc√™ pode criar uma fun√ß√£o em cada then e processar a exce√ß√£o:

	doSomething1()

	 .then(() => {

	 return doSomething2().catch(err => {

	 // trata o erro

	 throw err // quebre a corrente!

	 })

	 })

	 .then(() => {

	 return doSomething2().catch(err => {

	 // trata o erro

	 throw err // quebra a corrente!

	 })

	 })

	 .catch(err => console.error(err))

	Tratando erros com async/await

	Usando async/await, voc√™ ainda precisa tratar erros, e voc√™ pode fazer isso dessa forma:

	async function someFunction() {

	 try {

	 await someOtherFunction()

	 } catch (err) {

	 console.error(err.message)

	 }

	}

	Como fazer log de um objeto no Node.js

	Quando voc√™ digita console.log() em um programa JavaScript e o roda no browser, isso vai criar uma entrada bem legal no Console do Browser:



	Ao clicar na flecha, o log √© expandido, e voc√™ pode ver claramente as propriedades do objeto:



	No Node.js, o mesmo acontece.

	N√≥s n√£o temos tanto luxo quando logamos algo no console, porque isso vai retornar o objeto para o shell se voc√™ rodar o programa Node.js manualmente, ou para um arquivo de log. Voc√™ obt√™m uma representa√ß√£o do objeto em formato de string.

	Agora, tudo fica bem at√© um certo n√≠vel de aninhamento. Depois de dois n√≠veis de aninhamento, o Node.js desiste e imprime [Object] como um placeholder:

	const obj = {

	 name: 'joe',

	 age: 35,

	 person1: {

	 name: 'Tony',

	 age: 50,

	 person2: {

	 name: 'Albert',

	 age: 21,

	 person3: {

	 name: 'Peter',

	 age: 23

	 }

	 }

	 }

	}

	console.log(obj)





	{

	 name: 'joe',

	 age: 35,

	 person1: {

	 name: 'Tony',

	 age: 50,

	 person2: {

	 name: 'Albert',

	 age: 21,

	 person3: [Object]

	 }

	 }

	}

	Como voc√™ pode imprimir o objeto inteiro?

	A melhor maneira de fazer isso, preservando a beleza da sa√≠da, √© usar:

	console.log(JSON.stringify(obj, null, 2))

	sendo 2 o n√∫mero de espa√ßos usados para identa√ß√£o.

	Outra op√ß√£o √© usar

	require('util').inspect.defaultOptions.depth = null

	console.log(obj)

	mas o problema √© que objetos aninhados com mais de 2 n√≠veis ficam planificados, e isso pode ser um problema com objetos complexos.

	Refer√™ncias

	Revisado, Editado e baseado na documenta√ß√£o oficial do NodeJS, da qual possue licen√ßa MIT, que permite a livre redistribui√ß√£o.

	Agradecimento especial ao meu estagi√°rio Matheus Rocha que trabalhou duro para esta apostila sair!

	Meu objetivo √© levar conhecimento e acessibilidade a todos, muito obrigado por ter lido at√© aqui.

	Se tiver qualquer d√∫vida me pergunte qualquer coisa no Instagram, fa√ßo mentoria coletiva (gratuita) para programadores iniciantes que se sentem perdidos, voc√™ ser√° extremamente bem vindo por l√° (√© s√≥ clicar na imagem).



	Um grande abra√ßo, Paulo Luan.





* * *





	Se voc√™ quiser dar o proximo passo para ser um dev profissional, eu posso te mentorar! √© s√≥ voc√™ clicar aqui.

	 	‚Üê Como estudar Ci√™ncias da Computa√ß√£o (sem vestibular e de gra√ßa)

	Como fazer perguntas sobre programa√ß√£o na internet? (e aumentar 5x as chances de ter uma resposta) ‚Üí



	¬© 2024, Sua melhor escolha para aprender programa√ß√£o: Reativa Tecnologia





